{"version":3,"sources":["index.js"],"names":["COMPARABLE_DATE_FORMAT","Date","Graph","props","out","console","log","graph_data","ticker","data","type","label","concat","width","height","chartType","loader","options","chart","title","series","color","axes","y","Price","rootProps","getGraphDataFromTicker","raw_data","tr","Object","keys","historical_dates","last_historical_date","length","predicted_dates","Array","map","date","moment","toDate","push","Screen","tickers","state","response","loadDataFromAPI","screen","request_data","$","post","setState","render","selected_ticker","this","value","onChange","handleSelectChange","className","renderGraph","renderSelect","React","Component","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.b1402711.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport $ from 'jquery';\n\n// https://react-google-charts.com/line-chart\nimport Chart from \"react-google-charts\";\nimport Select from 'react-select'\nimport moment from 'moment';\n\n\n// function getData() {\n// \t// Fetch data from the backend to plot\n\t\n\n// }\n\n\n\n\n\n\n// TODO: Use the selected ticker to also change the selected graph data and then re-render the graph accordingly \n\nconst PREDICTION_ENDPOINT = \"https://backend.danshiebler.com/prediction\";\nconst COMPARABLE_DATE_FORMAT = \"YYYYMMDD\"\nconst DEFAULT_TICKER = null\nconst DEFAULT_GRAPH_DATA = [[new Date(2020, 1, 1), 0, null]]\nconst HISTORICAL = \"historical\"\nconst PREDICTIONS = \"predictions\"\n\nfunction Graph(props) {\n\tconsole.log(\"props.graph_data\")\n\tconsole.log(props.graph_data)\n\n\tvar out;\n\tif (props.ticker) {\n\t\tconst data = [[\n\t\t  { type: 'date', label: 'Day' },\n\t\t  'Closing Price for ' + props.ticker,\n\t\t  'Predicted Closing Price for ' + props.ticker\n\t\t\t]].concat(props.graph_data)\n\n\t\tconsole.log(\"data\")\n\t\tconsole.log(data)\n\n\n\t\tout =\t<Chart\n\t\t\t  width={'100%'}\n\t\t\t  height={'500'}\n\t\t\t  chartType=\"Line\"\n\t\t\t  loader={<div>Loading Chart</div>}\n\t\t\t  data={data}\n\t\t\t  options={{\n\t\t\t    chart: {\n\t\t\t      title:\n\t\t\t        \"Historical and Predicted Closing Prices for \" + props.ticker,\n\t\t\t    },\n\t\t\t    width: 900,\n\t\t\t    height: 500,\n\t\t\t    series: {\n\t\t\t\t\t\t0: { color: '#e2431e' },\n\t\t\t\t\t\t1: { color: '#1c91c0' },\n\t\t\t    },\n\t\t\t    axes: {\n\t\t\t      // Adds labels to each axis; they don't have to match the axis names.\n\t\t\t      y: {\n\t\t\t        Price: { label: 'Closing Price' },\n\t\t\t        // Daylight: { label: 'Daylight' },\n\t\t\t      },\n\t\t\t    },\n\t\t\t  }}\n\t\t\t  rootProps={{ 'data-testid': '4' }}\n\t\t\t/>\n\t} else {\n\t\tconsole.log(\"showing nothing\")\n\t\tout = null\n\t}\n\treturn out;\n}\n\n\n// function getDataFromAPI() {\n\n// \t// return {\n// \t// \t\"historical\": {\n// \t// \t\t\t\"DJI\": {\n// \t// \t\t\t\t\"20200101\": 0.5,\n// \t// \t\t\t\t\"20200102\": 0.6,\n// \t// \t\t\t\t\"20200103\": 0.7,\n// \t// \t\t\t\t\"20200104\": 0.8,\n// \t// \t\t\t\t\"20200105\": 1.0,\n// \t// \t\t\t\t\"20200106\": 1.2,\n// \t// \t\t\t},\n// \t// \t\t\t\"AMD\": {\n// \t// \t\t\t\t\"20200101\": 2.5,\n// \t// \t\t\t\t\"20200102\": 2.6,\n// \t// \t\t\t\t\"20200103\": 2.3,\n// \t// \t\t\t\t\"20200104\": 2.8,\n// \t// \t\t\t\t\"20200105\": 4.0,\n// \t// \t\t\t\t\"20200106\": 4.2,\n// \t// \t\t\t}\n// \t// \t\t},\n// \t// \t\"predicted\": {\n// \t// \t\t\t\"DJI\": {\n// \t// \t\t\t\t\"20200107\": 1.4\n// \t// \t\t\t},\n// \t// \t\t\t\"AMD\": {\n// \t// \t\t\t\t\"20200107\": 3.9\n// \t// \t\t\t}\n// \t// \t\t}\n// \t// }\n// }\n\n\nfunction getGraphDataFromTicker(raw_data, tr) {\n\n\tconsole.log(\"getGraphDataFromTicker - raw_data\")\n\tconsole.log(raw_data)\n\n\tconst dates = Object.keys(raw_data[HISTORICAL][tr]).concat(\n\t\tObject.keys(raw_data[PREDICTIONS][tr])\n\t)\n\n\tconst historical_dates = Object.keys(raw_data[HISTORICAL][tr])\n\tconst last_historical_date = historical_dates[historical_dates.length - 1]\n\tconst predicted_dates = Object.keys(raw_data[PREDICTIONS][tr])\n\n\n\tvar graph_data = new Array()\n\tgraph_data = graph_data.concat(historical_dates.map(date => (\n\t  [moment(date, COMPARABLE_DATE_FORMAT).toDate(), raw_data[HISTORICAL][tr][date], null]\n\t)))\n\n\t// We need to start the predicted line to overlap with the historical line, so we duplicate this point\n\tgraph_data.push(\n\t\t[moment(last_historical_date, COMPARABLE_DATE_FORMAT).toDate(),\n\t\traw_data[HISTORICAL][tr][last_historical_date],\n\t\traw_data[HISTORICAL][tr][last_historical_date]]\n\t)\n\n\tgraph_data = graph_data.concat(predicted_dates.map(date => (\n\t  [moment(date, COMPARABLE_DATE_FORMAT).toDate(), null, raw_data[PREDICTIONS][tr][date]]\n\t)))\n\n  return graph_data\n }\n\nclass Screen extends React.Component {\n  \"use strict\"\n\n  constructor(props) {\n    super(props);\n    this.raw_data = null\n    this.tickers = null;\n\t\tthis.state = {\n    \tresponse: null,\n    \tticker: null,\n    \tgraph_data: null\n    }\n    this.loadDataFromAPI(this)\n  }\n\n  loadDataFromAPI(screen) {\n\t\t// We only need to hit the backend to fetch data if the graph data is none\n\t\tif (!screen.state.graph_data) {\n\n\n\t\t\t// Start with a get query to get the \n\n\n\t\t\tconsole.log(\"Pulling data\")\n\t\t\tconst request_data = \"date=today&label_column=Close\";\n\n\t\t\t// TODO: Change this to get the next weekday after the specified date.\n\n\t\t\tconsole.log(\"request_data\")\n\t\t\tconsole.log(request_data)\n\n\t\t\t$.post(\n\t\t\t\tPREDICTION_ENDPOINT,\n\t\t\t\trequest_data,\n\t\t\t\tfunction(response) {\n\t\t\t\t\tconsole.log(\"Received response, setting variables\")\n\t\t\t\t\tconsole.log(response)\n\t\t\t\t\tscreen.raw_data = response[\"data\"]\n\t\t\t\t\tscreen.tickers = Object.keys(screen.raw_data[\"historical\"])\n\t\t\t    screen.setState({\n\t\t\t    \tresponse: null,\n\t\t\t    \tticker: screen.tickers[0],\n\t\t\t    \tgraph_data: getGraphDataFromTicker(screen.raw_data, screen.tickers[0])\n\t\t\t    })\n\t\t\t    screen.render()\n\t\t\t\t},\n\t\t\t\t'json'\n\t\t\t)\n\t\t} else {\n\t\t\tconsole.log(\"Not pulling new data\")\n\t\t}\n  }\n\n  handleSelectChange(selected_ticker) {\n    this.setState({\n    \tresponse: this.state.response,\n    \tticker: selected_ticker.value,\n    \tgraph_data: getGraphDataFromTicker(this.raw_data, selected_ticker.value)\n  \t})\n  }\n\n  renderGraph() {\n\n    return <Graph\n        ticker={this.state.ticker}\n        graph_data={this.state.graph_data}\n        />;\n  }\n\n  renderSelect() {\n  \tvar out = null;\n  \tif (this.tickers) {\n\t\t\t// https://www.npmjs.com/package/react-select\n\t \t  const options = this.tickers.map(ticker => (\n\t\t\t\t  { value: ticker, label: ticker }\n\t\t\t))\n\t  \tout = <Select \n\t  \t\toptions={options}\n\t  \t\tonChange={\n\t  \t\t\t// NOTE: We build an anonymous function here so that `this` is still available inside of handleSelectChange\n\t  \t\t\t(selected_ticker) => this.handleSelectChange(selected_ticker)}\n\t  \t/>;\n\n\t  \tconsole.log(out)\n  \t}\n\t  return out;\n  }\n\n\n  render() {\n  \t// NOTE: The render method is called each time the state is updated\n    console.log(\"rendering\");\n    return (\n      <div>\n        <div className=\"graph\">\n          {this.renderGraph()}\n        </div>\n        <div className=\"select\">\n          {this.renderSelect()}\n        </div>\n      </div>\n    );\n  }\n}\n\n\n\n\n\n// class Graph extends React.Component {\n//   \"use strict\"\n\n//   render() {\n//     console.log(\"rendering graph\");\n//     return (\n\n//       <div>\n\n//       </div>\n//     );\n//   }\n// }\n\n\n// ========================================\n\nReactDOM.render(\n  <Screen />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}