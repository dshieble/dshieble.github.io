I"^B<script> 
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-82391879-1', 'auto');
  ga('send', 'pageview');

</script>

<p>I recently worked through Bartosz Milewski’s excellent free book “Category Theory for Programmers.” The book is available online <a href="https://github.com/hmemcpy/milewski-ctfp-pdf/">here</a> and <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">here</a>.</p>

<p>I had an awesome time reading the book and learning about Category Theory so I figured I’d post my solutions to the book problems online to make it easier for other people to have a similar experience. You can find my solutions below:</p>

<h1 id="section-1">Section 1</h1>
<h5 id="p11">p1.1</h5>
<h5 id="implement-as-best-as-you-can-the-identity-function-in-your-favorite-language-or-the-second-favorite-if-your-favorite-language-happens-to-be-haskell">Implement, as best as you can, the identity function in your favorite language (or the second favorite, if your favorite language happens to be Haskell).</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<h5 id="p12">p1.2</h5>
<h5 id="implement-the-composition-function-in-your-favorite-language-it-takes-two-functions-as-arguments-and-returns-a-function-that-is-their-composition">Implement the composition function in your favorite language. It takes two functions as arguments and returns a function that is their composition.</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f2</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></div></div>

<h5 id="p13">p1.3</h5>
<h5 id="write-a-program-that-tries-to-test-that-your-composition-function-respects-identity">Write a program that tries to test that your composition function respects identity.</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="n">compose</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">identity</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span>
<span class="k">assert</span> <span class="n">compose</span><span class="p">(</span><span class="n">identity</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span>
</code></pre></div></div>

<h5 id="p14">p1.4</h5>
<h5 id="is-the-world-wide-web-a-category-in-any-sense-are-links-morphisms">Is the world-wide web a category in any sense? Are links morphisms?</h5>
<p><em>Solution</em>
The world wide web is indeed a category if we consider the objects to be webpages and for there to be an “arrow” between <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> if there is a way to get to <code class="language-plaintext highlighter-rouge">B</code> from <code class="language-plaintext highlighter-rouge">A</code> by clicking on links</p>

<h5 id="p15">p1.5</h5>
<h5 id="is-facebook-a-category-with-people-as-objects-and-friendships-as-morphisms">Is Facebook a category, with people as objects and friendships as morphisms?</h5>
<p><em>Solution</em>
No, because just because <code class="language-plaintext highlighter-rouge">A -&gt; B</code> and <code class="language-plaintext highlighter-rouge">B -&gt; C</code> does not imply <code class="language-plaintext highlighter-rouge">A -&gt; C</code></p>

<h5 id="p16">p1.6</h5>
<h5 id="when-is-a-directed-graph-a-category">When is a directed graph a category?</h5>
<p><em>Solution</em>
Whenever every node has an edge that points back to it and for every two nodes <code class="language-plaintext highlighter-rouge">A, B</code> such that there is a path from <code class="language-plaintext highlighter-rouge">A</code> to <code class="language-plaintext highlighter-rouge">B</code>, there is also an edge connecting <code class="language-plaintext highlighter-rouge">A</code> to <code class="language-plaintext highlighter-rouge">B</code>.</p>

<h1 id="section-2">Section 2</h1>
<h5 id="p21-define-a-higher-order-function-or-a-function-object-memoize-in-your-favorite-language-this-function-takes-a-pure-function-f-as-an-argument-and-returns-a-function-that-behaves-almost-exactly-like-f-except-that-it-only-calls-the-original-function-once-for-every-argument-stores-the-result-internally-and-subsequently-returns-this-stored-result-every-time-its-called-with-the-same-argument-you-can-tell-the-memoized-function-from-the-original-by-watching-its-performance-for-instance-try-to-memoize-a-function-that-takes-a-long-time-to-evaluate-youll-have-to-wait-for-the-result-the-first-time-you-call-it-but-on-subsequent-calls-with-the-sameargument-you-should-get-the-result-immediately">p2.1 Define a higher-order function (or a function object) <code class="language-plaintext highlighter-rouge">memoize</code> in your favorite language. This function takes a pure function <code class="language-plaintext highlighter-rouge">f</code> as an argument and returns a function that behaves almost exactly like <code class="language-plaintext highlighter-rouge">f</code>, except that it only calls the original function once for every argument, stores the result internally, and subsequently returns this stored result every time it’s called with the same argument. You can tell the memoized function from the original by watching its performance. For instance, try to memoize a function that takes a long time to evaluate. You’ll have to wait for the result the first time you call it, but on subsequent calls, with the sameargument, you should get the result immediately.</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="n">calls</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">def</span> <span class="nf">memoized</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">calls</span><span class="p">:</span>
      <span class="n">calls</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">calls</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">memoized</span>
</code></pre></div></div>

<h5 id="p22-try-to-memoize-a-function-from-your-standard-library-that-you-normally-use-to-produce-random-numbers-does-it-work">p2.2 Try to memoize a function from your standard library that you normally use to produce random numbers. Does it work?</h5>
<p><em>Solution</em>
This will not work</p>

<h5 id="p23-most-random-number-generators-can-be-initialized-with-a-seed-implement-a-function-that-takes-a-seed-calls-the-random-number-generator-with-that-seed-and-returns-the-result-memoize-that-function-does-it-work">p2.3 Most random number generators can be initialized with a seed. Implement a function that takes a seed, calls the random number generator with that seed, and returns the result. Memoize that function. Does it work?</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">seed_to_random</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
  <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span>
<span class="n">memoized_random</span> <span class="o">=</span> <span class="n">memoize</span><span class="p">(</span><span class="n">seed_to_random</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">memoized_random</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">memoized_random</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="k">assert</span> <span class="n">memoized_random</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">memoized_random</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="p23-which-of-these-c-functions-are-pure-try-to-memoize-them-and-observe-what-happens-when-you-call-them-multiple-times-memoized-and-not">p2.3 Which of these C++ functions are pure? Try to memoize them and observe what happens when you call them multiple times: memoized and not.</h5>
<h5 id="a-the-factorial-function-from-the-example-in-the-text">a: The factorial function from the example in the text.</h5>
<p><em>Solution</em>
<code class="language-plaintext highlighter-rouge">factorial</code> is a pure function</p>

<h5 id="b-stdgetchar">b: <code class="language-plaintext highlighter-rouge">std::getchar()</code></h5>
<p><em>Solution</em>
<code class="language-plaintext highlighter-rouge">getchar</code> is not a pure function, since it relies on the state of <code class="language-plaintext highlighter-rouge">stdin</code></p>

<h5 id="c">c:</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><em>Solution</em>
<code class="language-plaintext highlighter-rouge">f</code> is not a pure function, since it has the side effect of printing</p>
<h5 id="d">d:</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><em>Solution</em>
<code class="language-plaintext highlighter-rouge">f</code> is not a pure function, since it both has the side effect of incrementing <code class="language-plaintext highlighter-rouge">y</code> and relies on the state of static variable <code class="language-plaintext highlighter-rouge">y</code></p>

<h5 id="p25-how-many-different-functions-are-there-from-bool-to-bool-can-you-implement-them-all">p2.5 How many different functions are there from <code class="language-plaintext highlighter-rouge">Bool</code> to <code class="language-plaintext highlighter-rouge">Bool</code>? Can you implement them all?</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">same</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">same</span> <span class="n">trueorfalse</span> <span class="o">=</span> <span class="n">trueorfalse</span>

<span class="n">opposite</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">opposite</span> <span class="n">trueorfalse</span> <span class="o">=</span> <span class="n">not</span> <span class="n">trueorfalse</span>

<span class="n">alwaystrue</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">alwaystrue</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">True</span>

<span class="n">alwaysfalse</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">alwaysfalse</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">False</span>
</code></pre></div></div>

<h1 id="section-3">Section 3</h1>

<h5 id="p31-generate-a-free-category-from">p3.1 Generate a free category from:</h5>
<ul>
  <li>
    <p><strong>A graph with one node and no edges</strong>
<em>Solution</em>
Add an identity arrow.</p>
  </li>
  <li>
    <p><strong>A graph with one node and one (directed) edge (hint: this edge can be composed with itself)</strong>
<em>Solution</em>
Add infinite arrows to represent every number of applications of the directed edge.</p>
  </li>
  <li>
    <p><strong>A graph with two nodes and a single arrow between them</strong>
<em>Solution</em>
Add identity arrows.</p>
  </li>
  <li>
    <p><strong>A graph with a single node and 26 arrows marked with the letters of the alphabet: a, b, c … z.</strong>
<em>Solution</em>
Add an identity arrow, and then add infinite arrows, one for every combination of a-z of any length.</p>
  </li>
</ul>

<h5 id="p32--what-kind-of-order-is-this">p3.2  What kind of order is this?</h5>
<ul>
  <li><strong>A set of sets with the inclusion relation: <code class="language-plaintext highlighter-rouge">A</code> is included in <code class="language-plaintext highlighter-rouge">B</code> if every element of <code class="language-plaintext highlighter-rouge">A</code> is also an element of <code class="language-plaintext highlighter-rouge">B</code>.</strong>
 <em>Solution</em>
This is a partial order.
    <ul>
      <li>For any <code class="language-plaintext highlighter-rouge">(a, b)</code> there is at most one <code class="language-plaintext highlighter-rouge">a -&gt; b</code> and if <code class="language-plaintext highlighter-rouge">a -&gt; b</code> and <code class="language-plaintext highlighter-rouge">b -&gt; a</code> then <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> have the same elements and are the same set.</li>
      <li>Since there might be some <code class="language-plaintext highlighter-rouge">(a, b)</code> where <code class="language-plaintext highlighter-rouge">a intersect b</code> is empty, this is not a total order</li>
    </ul>
  </li>
  <li><strong>C++ types with the following subtyping relation: <code class="language-plaintext highlighter-rouge">T1</code> is a subtype of <code class="language-plaintext highlighter-rouge">T2</code> if a pointer to <code class="language-plaintext highlighter-rouge">T1</code> can be passed to a function that expects a pointer to <code class="language-plaintext highlighter-rouge">T2</code> without triggering a compilation error.</strong>
<em>Solution</em>
This is a partial order.
    <ul>
      <li>For any <code class="language-plaintext highlighter-rouge">(t1, t2)</code> there is at most one <code class="language-plaintext highlighter-rouge">t1 -&gt; t2</code>, and if <code class="language-plaintext highlighter-rouge">t1 -&gt; t2</code> and <code class="language-plaintext highlighter-rouge">t2 -&gt; t1</code> then <code class="language-plaintext highlighter-rouge">t1</code> and <code class="language-plaintext highlighter-rouge">t2</code> are the same type.</li>
      <li>There are types not connected by a subtype relation, so this is not a total order.</li>
    </ul>
  </li>
</ul>

<h5 id="p33--considering-that-bool-is-a-set-of-two-values-true-and-false-show-that-it-forms-two-set-theoretical-monoids-with-respect-to-respectivelyoperator-and-and-or">p3.3  Considering that <code class="language-plaintext highlighter-rouge">Bool</code> is a set of two values <code class="language-plaintext highlighter-rouge">True</code> and <code class="language-plaintext highlighter-rouge">False</code>, show that it forms two (set-theoretical) monoids with respect to, respectively,operator <code class="language-plaintext highlighter-rouge">AND</code> and <code class="language-plaintext highlighter-rouge">OR</code>.</h5>
<p><em>Solution</em>
<strong>AND</strong>
    * <strong>Closure</strong>: The output of <code class="language-plaintext highlighter-rouge">AND</code> is boolean
    * <strong>Identity</strong>: The identity is <code class="language-plaintext highlighter-rouge">True</code>
    * <strong>Associative</strong>: Easy to show by enumeration</p>

<p><strong>OR</strong>
    * <strong>Closure</strong>: The output of <code class="language-plaintext highlighter-rouge">OR</code> is boolean
    * <strong>Identity</strong>: The identity is <code class="language-plaintext highlighter-rouge">False</code>
    * <strong>Associative</strong>: Easy to show by enumeration</p>

<h5 id="p34--represent-the-bool-monoid-with-the-and-operator-as-a-category-list-the-morphisms-and-their-rules-of-composition">p3.4  Represent the <code class="language-plaintext highlighter-rouge">Bool</code> monoid with the <code class="language-plaintext highlighter-rouge">AND</code> operator as a category: List the morphisms and their rules of composition.</h5>
<p><em>Solution</em>
The single element in this category is the <code class="language-plaintext highlighter-rouge">Bool</code> type. The morphisms are <code class="language-plaintext highlighter-rouge">AND True</code> (identity) and <code class="language-plaintext highlighter-rouge">AND False</code>. The composition of these two is <code class="language-plaintext highlighter-rouge">AND False</code>.</p>

<h5 id="p35--represent-addition-modulo-3-as-a-monoid-category">p3.5  Represent addition modulo 3 as a monoid category.</h5>
<p><em>Solution</em>
The single element in this category is the the type <code class="language-plaintext highlighter-rouge">[Int &lt; 3, &gt;= 0]</code>.
The morphisms are
    * A: add <code class="language-plaintext highlighter-rouge">3n</code> (identity)
    * B: add <code class="language-plaintext highlighter-rouge">1 + 3n</code>
    * C: add <code class="language-plaintext highlighter-rouge">2 + 3n</code>
The morphisms in this category are closed under association because <code class="language-plaintext highlighter-rouge">B . B</code> is <code class="language-plaintext highlighter-rouge">C</code> and both <code class="language-plaintext highlighter-rouge">B . C</code>, <code class="language-plaintext highlighter-rouge">C . B</code> are <code class="language-plaintext highlighter-rouge">A</code></p>

<h1 id="section-4">Section 4</h1>
<h5 id="p41-construct-the-kleisli-category-for-partial-functions-define-composition-and-identity">p4.1 Construct the Kleisli category for partial functions (define composition and identity).</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Optional</span><span class="p">:</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>

  <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

  <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="p">.</span><span class="n">is_valid</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_value</span>

<span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">composed</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">f1out</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f2</span><span class="p">(</span><span class="n">f1out</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="k">if</span> <span class="n">f1out</span><span class="p">.</span><span class="n">is_valid</span><span class="p">()</span> <span class="k">else</span> <span class="n">Optional</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">composed</span>

<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">Optional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="p42-implement-the-embellished-function-safe_reciprocal-that-returns-a-valid-reciprocal-of-its-argument-if-its-different-from-zero">p4.2 Implement the embellished function <code class="language-plaintext highlighter-rouge">safe_reciprocal</code> that returns a valid reciprocal of its argument, if it’s different from zero.</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">safe_root</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">Optional</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">Optional</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">safe_reciprocal</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">Optional</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">Optional</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

<span class="k">assert</span> <span class="ow">not</span> <span class="n">safe_root</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">is_valid</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">safe_root</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="n">get</span><span class="p">(),</span> <span class="mf">2.0</span><span class="p">)</span>

<span class="k">assert</span> <span class="ow">not</span> <span class="n">safe_reciprocal</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">is_valid</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">safe_reciprocal</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="n">get</span><span class="p">(),</span> <span class="mf">0.25</span><span class="p">)</span>

</code></pre></div></div>

<h5 id="p43-compose-safe_root-and-safe_reciprocal-to-implement-safe_root_reciprocal-that-calculates-sqrt1x-whenever-possible">p4.3 Compose <code class="language-plaintext highlighter-rouge">safe_root</code> and <code class="language-plaintext highlighter-rouge">safe_reciprocal</code> to implement <code class="language-plaintext highlighter-rouge">safe_root_reciprocal</code> that calculates <code class="language-plaintext highlighter-rouge">sqrt(1/x)</code> whenever possible.</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">safe_root_reciprocal</span> <span class="o">=</span> <span class="n">compose</span><span class="p">(</span><span class="n">safe_reciprocal</span><span class="p">,</span> <span class="n">safe_root</span><span class="p">)</span>

<span class="k">assert</span> <span class="ow">not</span> <span class="n">safe_root_reciprocal</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">is_valid</span><span class="p">()</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">safe_root_reciprocal</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">).</span><span class="n">is_valid</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">safe_root_reciprocal</span><span class="p">(</span><span class="mf">0.25</span><span class="p">).</span><span class="n">get</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>

</code></pre></div></div>

<h1 id="section-5">Section 5</h1>

<h5 id="p51-show-that-the-terminal-object-is-unique-up-to-unique-isomorphism">p5.1 Show that the terminal object is unique up to unique isomorphism.</h5>
<p><em>Solution</em>
Consider two terminal objects <code class="language-plaintext highlighter-rouge">A, B</code>. There is exactly one morphism <code class="language-plaintext highlighter-rouge">m1</code> from <code class="language-plaintext highlighter-rouge">A -&gt; B</code> since <code class="language-plaintext highlighter-rouge">B</code> is terminal and exactly one morphism <code class="language-plaintext highlighter-rouge">m2</code> from <code class="language-plaintext highlighter-rouge">B -&gt; A</code> since <code class="language-plaintext highlighter-rouge">A</code> is terminal. Then <code class="language-plaintext highlighter-rouge">m1 . m2</code> is a morphism from <code class="language-plaintext highlighter-rouge">B -&gt; B</code> and <code class="language-plaintext highlighter-rouge">m2 . m1</code> is a morphism from <code class="language-plaintext highlighter-rouge">A -&gt; A</code>. Since <code class="language-plaintext highlighter-rouge">B</code> is terminal, there is exactly one morphism from <code class="language-plaintext highlighter-rouge">B -&gt; B</code>, so <code class="language-plaintext highlighter-rouge">m1 . m2</code> is the identity.</p>

<p>Therefore <code class="language-plaintext highlighter-rouge">m1, m2</code> form an isomorphism between <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>. Since there are no other morphisms between <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>, <code class="language-plaintext highlighter-rouge">m1, m2</code> is a unique isomorphism.</p>

<h5 id="p52-what-is-a-product-of-two-objects-in-a-poset-hint-use-the-universal-construction">p5.2 What is a product of two objects in a poset? Hint: Use the universal construction.</h5>
<p><em>Solution</em>
The product of two objects <code class="language-plaintext highlighter-rouge">A, B</code> in a poset is the object <code class="language-plaintext highlighter-rouge">C</code> that is less than both <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> (i.e. exists: <code class="language-plaintext highlighter-rouge">p: C -&gt; A</code> and <code class="language-plaintext highlighter-rouge">q: C -&gt; B</code>) and for any other object <code class="language-plaintext highlighter-rouge">D</code> that is also less than <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>, exists <code class="language-plaintext highlighter-rouge">D -&gt; C</code>. This object does not always exist.</p>

<p><strong>Sufficiency</strong>
Say we have such an <code class="language-plaintext highlighter-rouge">A, B, C</code>. Now consider some object <code class="language-plaintext highlighter-rouge">D</code> such that <code class="language-plaintext highlighter-rouge">p2: D -&gt; A</code>, <code class="language-plaintext highlighter-rouge">q2: D -&gt; B</code>. Then we have some <code class="language-plaintext highlighter-rouge">m: D -&gt; C</code> so <code class="language-plaintext highlighter-rouge">p1 . m: D -&gt; A</code> and <code class="language-plaintext highlighter-rouge">q1 . m: D -&gt; B</code>. Now since there is at most one morphism between any pair of objects in a poset, it’s true that <code class="language-plaintext highlighter-rouge">p2 = p1 . m</code> and <code class="language-plaintext highlighter-rouge">q2 = q1 . m</code>, so <code class="language-plaintext highlighter-rouge">m</code> factorizes <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">q</code>.</p>

<p><strong>Necessity</strong>
If there were some object <code class="language-plaintext highlighter-rouge">D</code> such that <code class="language-plaintext highlighter-rouge">D -&gt; A</code>, <code class="language-plaintext highlighter-rouge">D -&gt; B</code> but not <code class="language-plaintext highlighter-rouge">D -&gt; C</code>, then there is no morphism <code class="language-plaintext highlighter-rouge">m</code> such that <code class="language-plaintext highlighter-rouge">p1 = p2 . m</code> since <code class="language-plaintext highlighter-rouge">m</code> must be a morphism from <code class="language-plaintext highlighter-rouge">D -&gt; C</code>. Therefore <code class="language-plaintext highlighter-rouge">C</code> is not the product of <code class="language-plaintext highlighter-rouge">A,B</code>.</p>

<h5 id="p53-what-is-a-coproduct-of-two-objects-in-a-poset">p5.3 What is a coproduct of two objects in a poset?</h5>
<p><em>Solution</em>
We just reverse the arrows in <strong>p5.2</strong>. The coproduct of two objects <code class="language-plaintext highlighter-rouge">A, B</code> in a poset is the object <code class="language-plaintext highlighter-rouge">C</code> that is greater than both <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> (i.e. exists: <code class="language-plaintext highlighter-rouge">p: A -&gt; C</code> and <code class="language-plaintext highlighter-rouge">q: B -&gt; C</code>) and for any other object <code class="language-plaintext highlighter-rouge">D</code> that is also greater than <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>, exists <code class="language-plaintext highlighter-rouge">C -&gt; D</code>.  This object does not always exist.</p>

<h5 id="p54-implement-the-equivalent-of-haskell-either-as-a-generic-type-in-your-favorite-language-other-than-haskell">p5.4 Implement the equivalent of Haskell <code class="language-plaintext highlighter-rouge">Either</code> as a generic type in your favorite language (other than Haskell).</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">EitherAbstract</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">pass</span>

<span class="k">class</span> <span class="nc">RightEither</span><span class="p">(</span><span class="n">EitherAbstract</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">LeftEither</span><span class="p">(</span><span class="n">EitherAbstract</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>

<span class="c1"># doing something like this in python is a recipe for disaster :)
</span><span class="k">def</span> <span class="nf">either_factory</span><span class="p">(</span><span class="n">left_type</span><span class="p">,</span> <span class="n">right_type</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="p">((</span><span class="n">left</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">right</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">left_type</span><span class="p">)</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">LeftEither</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">right_type</span><span class="p">)</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">RightEither</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="k">return</span> <span class="n">generate</span>

<span class="n">my_left</span> <span class="o">=</span> <span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)(</span><span class="n">left</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">my_left</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="mi">5</span>


<span class="n">my_right</span> <span class="o">=</span> <span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)(</span><span class="n">right</span><span class="o">=</span><span class="s">"5"</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">my_right</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="s">"5"</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
  <span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)()</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"failed"</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">AssertionError</span><span class="p">:</span>
  <span class="k">pass</span>

<span class="k">try</span><span class="p">:</span>
  <span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)(</span><span class="n">left</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="s">"5"</span><span class="p">)</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"failed"</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">AssertionError</span><span class="p">:</span>
  <span class="k">pass</span>
</code></pre></div></div>

<h5 id="p55-show-that-either-is-a-better-coproduct-than-int-equipped-with-two-injections">p5.5 Show that <code class="language-plaintext highlighter-rouge">Either</code> is a “better” coproduct than <code class="language-plaintext highlighter-rouge">int</code> equipped with two injections:</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="o">?</span> <span class="mi">0</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>
<p><strong>Hint: Define a function <code class="language-plaintext highlighter-rouge">int m(Either const &amp; e);</code> that factorizes <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>.</strong>
<em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Consider the following injections from int and bool into int
</span><span class="k">def</span> <span class="nf">int_to_int</span><span class="p">(</span><span class="n">int_param</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">int_param</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">int_param</span>

<span class="k">def</span> <span class="nf">bool_to_int</span><span class="p">(</span><span class="n">bool_param</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bool_param</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">bool_param</span> <span class="k">else</span> <span class="mi">0</span>

<span class="c1"># We can define the following morphism from Either into int
</span><span class="k">def</span> <span class="nf">either_to_int</span><span class="p">(</span><span class="n">either_param</span><span class="p">):</span>
  <span class="nb">isinstance</span><span class="p">(</span><span class="n">either_param</span><span class="p">,</span> <span class="n">EitherAbstract</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">either_param</span><span class="p">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s">"left"</span><span class="p">:</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">int_to_int</span><span class="p">(</span><span class="n">either_param</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">either_param</span><span class="p">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s">"right"</span><span class="p">:</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">bool_to_int</span><span class="p">(</span><span class="n">either_param</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span>

<span class="s">"""
Then
bool_to_int(x) = either_to_int (either_factory(int, bool)(left=x))
int_to_int(y) = either_to_int (either_factory(int, bool)(right=y))
so either_to_int factorizes bool_to_int and int_to_int
"""</span>
<span class="k">assert</span> <span class="n">either_to_int</span><span class="p">(</span><span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)(</span><span class="n">left</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span> <span class="o">==</span> <span class="n">int_to_int</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">either_to_int</span><span class="p">(</span><span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)(</span><span class="n">right</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span> <span class="o">==</span> <span class="n">bool_to_int</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">either_to_int</span><span class="p">(</span><span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)(</span><span class="n">right</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span> <span class="o">==</span> <span class="n">bool_to_int</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="p56-continuing-the-previous-problem-how-would-you-argue-that-int-with-the-two-injections-i-and-j-cannot-be-better-than-either">p5.6 Continuing the previous problem: How would you argue that <code class="language-plaintext highlighter-rouge">int</code> with the two injections<code class="language-plaintext highlighter-rouge"> i</code> and <code class="language-plaintext highlighter-rouge">j</code> cannot be “better” than <code class="language-plaintext highlighter-rouge">Either</code>?</h5>
<p><em>Solution</em>
Say there exists some function <code class="language-plaintext highlighter-rouge">impossible_m</code> such that</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)(</span><span class="n">left</span><span class="o">=</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">impossible_m</span> <span class="p">(</span> <span class="n">int_to_int</span> <span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)(</span><span class="n">right</span><span class="o">=</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">impossible_m</span> <span class="p">(</span> <span class="n">bool_to_int</span> <span class="p">(</span><span class="n">y</span><span class="p">))</span>
</code></pre></div></div>
<p>For all <code class="language-plaintext highlighter-rouge">int x</code> and <code class="language-plaintext highlighter-rouge">bool y</code>. Then it must be the case that:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">impossible_m</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">LeftEither</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">impossible_m</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">RightEither</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>
<p>Which is not possible, because the output of a function for a given input argument must be unique.</p>

<h5 id="p57-still-continuing-what-about-these-injections">p5.7 Still continuing: What about these injections?</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="o">?</span> <span class="mi">0</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>
<p><em>Solution</em>
Say there exists some function <code class="language-plaintext highlighter-rouge">new_m</code> such that</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">int_to_int_2</span><span class="p">(</span><span class="n">int_param</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">int_param</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">int_param</span> <span class="k">if</span> <span class="n">int_param</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">int_param</span> <span class="o">+</span> <span class="mi">2</span>

<span class="n">either_factory</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)(</span><span class="n">left</span><span class="o">=</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_m</span> <span class="p">(</span> <span class="n">int_to_int_2</span> <span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></div></div>

<p>Then it must be the case that</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">new_m</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">LeftEither</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">x</span>
<span class="n">new_m</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">LeftEither</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">new_m</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">LeftEither</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">new_m</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="n">LeftEither</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">new_m</span><span class="p">(</span><span class="n">max_int</span><span class="p">)</span> <span class="o">=</span> <span class="n">Left</span><span class="p">(</span><span class="n">max_int</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>
<p>Since there are only a finite number of integers in python/C++, <code class="language-plaintext highlighter-rouge">Left(max_int - 1)</code> and <code class="language-plaintext highlighter-rouge">Left(max_int)</code> cannot be in the domain of <code class="language-plaintext highlighter-rouge">new_m</code>.</p>

<h5 id="p58-come-up-with-an-inferior-candidate-for-a-coproduct-of-int-and-bool-that-cannot-be-better-than-either-because-it-allows-multiple-acceptable-morphisms-from-it-to-either">p5.8 Come up with an inferior candidate for a coproduct of <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">bool</code> that cannot be better than <code class="language-plaintext highlighter-rouge">Either</code> because it allows multiple acceptable morphisms from it to <code class="language-plaintext highlighter-rouge">Either</code></h5>
<p><em>Solution</em></p>

<p>Consider some type <code class="language-plaintext highlighter-rouge">SuperEither</code> defined as</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">SuperEither</span> <span class="o">=</span> <span class="kt">IntBoolTuple</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">|</span> <span class="kt">BoolBoolTuple</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Bool</span><span class="p">)</span>
</code></pre></div></div>

<p>We can define injections into this type from <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">bool</code> of the forms</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">intint</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">SuperEither</span><span class="p">;</span>
<span class="n">intint</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">IntIntTuple</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="n">boolbool</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">SuperEither</span><span class="p">;</span>
<span class="n">boolbool</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">BoolBoolTuple</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>Then we can define multiple morphisms from <code class="language-plaintext highlighter-rouge">SuperEither</code> into <code class="language-plaintext highlighter-rouge">Either</code> that take either the first or second element.</p>

<h1 id="section-6">Section 6</h1>

<h5 id="p61-show-the-isomorphism-between-maybe-a-and-either--a">p6.1 Show the isomorphism between <code class="language-plaintext highlighter-rouge">Maybe a</code> and <code class="language-plaintext highlighter-rouge">Either () a</code>.</h5>
<p><em>Solution</em>
We can define the following two functions, which serve as inverses</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">maybeToEither</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="nb">()</span> <span class="n">a</span>
<span class="n">maybeToEither</span> <span class="n">inputMaybe</span> <span class="o">=</span>
  <span class="kr">case</span> <span class="n">inputMaybe</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Right</span> <span class="n">a</span>
    <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Left</span> <span class="nb">()</span>

<span class="n">eitherToMaybe</span> <span class="o">::</span> <span class="kt">Either</span> <span class="nb">()</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">eitherToMaybe</span> <span class="n">inputEither</span> <span class="o">=</span>
  <span class="kr">case</span> <span class="n">inputEither</span> <span class="kr">of</span>
    <span class="kt">Right</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="n">a</span>
    <span class="kt">Left</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<h5 id="p62-heres-a-sum-type-defined-in-haskell">p6.2 Here’s a sum type defined in Haskell:</h5>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="kt">Circle</span> <span class="kt">Float</span>
    <span class="o">|</span> <span class="kt">Rect</span> <span class="kt">Float</span> <span class="kt">Float</span>
</code></pre></div></div>
<h5 id="when-we-want-to-define-a-function-like-area-that-acts-on-a-shape-we-do-it-by-pattern-matching-on-the-two-constructors">When we want to define a function like area that acts on a <code class="language-plaintext highlighter-rouge">Shape</code>, we do it by pattern matching on the two constructors:</h5>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">area</span> <span class="o">::</span> <span class="kt">Shape</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">area</span> <span class="p">(</span><span class="kt">Circle</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span>
<span class="n">area</span> <span class="p">(</span><span class="kt">Rect</span> <span class="n">d</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">h</span>
</code></pre></div></div>
<h5 id="implement-shape-in-c-or-java-as-an-interface-and-create-two-classes-circle-and-rect-implement-area-as-a-virtual-function">Implement <code class="language-plaintext highlighter-rouge">Shape</code> in C++ or Java as an interface and create two classes: <code class="language-plaintext highlighter-rouge">Circle</code> and <code class="language-plaintext highlighter-rouge">Rect</code>. Implement area as a virtual function.</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># I'll use python again, just for fun
</span>
<span class="k">class</span> <span class="nc">AbstractShape</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">NotImplementedError</span><span class="p">()</span>

  <span class="k">def</span> <span class="nf">circ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">NotImplementedError</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Circle</span><span class="p">(</span><span class="n">AbstractShape</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>

  <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span>

  <span class="k">def</span> <span class="nf">circ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span>


<span class="k">class</span> <span class="nc">Rect</span><span class="p">(</span><span class="n">AbstractShape</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>

  <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">width</span>

  <span class="k">def</span> <span class="nf">circ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">height</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">width</span>

<span class="n">rect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">rect</span><span class="p">.</span><span class="n">circ</span><span class="p">()</span> <span class="o">==</span> <span class="mi">16</span>
<span class="k">assert</span> <span class="n">rect</span><span class="p">.</span><span class="n">area</span><span class="p">()</span> <span class="o">==</span> <span class="mi">15</span>
</code></pre></div></div>

<h5 id="p63-continuing-with-the-previous-example-we-can-easily-add-a-new-function-circ-that-calculates-the-circumference-of-a-shape-we-can-do-it-without-touching-the-definition-of-shape">p6.3 Continuing with the previous example: We can easily add a new function <code class="language-plaintext highlighter-rouge">circ</code> that calculates the circumference of a <code class="language-plaintext highlighter-rouge">Shape</code>. We can do it without touching the definition of <code class="language-plaintext highlighter-rouge">Shape</code>:</h5>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">circ</span> <span class="o">::</span> <span class="kt">Shape</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">circ</span> <span class="p">(</span><span class="kt">Circle</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
<span class="n">circ</span> <span class="p">(</span><span class="kt">Rect</span> <span class="n">d</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">h</span><span class="p">)</span>
</code></pre></div></div>
<h5 id="add-circ-to-your-c-or-java-implementation-what-parts-of-the-original-code-did-you-have-to-touch">Add <code class="language-plaintext highlighter-rouge">circ</code> to your C++ or Java implementation. What parts of the original code did you have to touch?</h5>
<p><em>Solution</em>
See above. We needed to add it to each class, including <code class="language-plaintext highlighter-rouge">AbstractShape</code>.</p>

<h5 id="p64-continuing-further-add-a-new-shape-square-to-shape-and-make-all-the-necessary-updates-what-code-did-you-have-to-touch-in-haskell-vs-c-or-java-even-if-youre-not-a-haskell-programmer-the-modifications-should-be-pretty-obvious">p6.4 Continuing further: Add a new shape, <code class="language-plaintext highlighter-rouge">Square</code>, to <code class="language-plaintext highlighter-rouge">Shape</code> and make all the necessary updates. What code did you have to touch in Haskell vs. C++ or Java? (Even if you’re not a Haskell programmer, the modifications should be pretty obvious.)</h5>
<p><em>Solution</em>
For haskell we need to update the <code class="language-plaintext highlighter-rouge">Shape</code> definition and add another line to <code class="language-plaintext highlighter-rouge">circ</code> and <code class="language-plaintext highlighter-rouge">area</code> implementations. For python we needed to write a new class with a new initializer, inheriting from <code class="language-plaintext highlighter-rouge">Rect</code></p>

<p>Haskell:</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rect</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Square</span> <span class="kt">Float</span>

<span class="n">area</span> <span class="o">::</span> <span class="kt">Shape</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">area</span> <span class="p">(</span><span class="kt">Circle</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span>
<span class="n">area</span> <span class="p">(</span><span class="kt">Rect</span> <span class="n">d</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">h</span>
<span class="n">area</span> <span class="p">(</span><span class="kt">Square</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">h</span>

<span class="n">circ</span> <span class="o">::</span> <span class="kt">Shape</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">circ</span> <span class="p">(</span><span class="kt">Circle</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
<span class="n">circ</span> <span class="p">(</span><span class="kt">Rect</span> <span class="n">d</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">h</span><span class="p">)</span>
<span class="n">circ</span> <span class="p">(</span><span class="kt">Square</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">h</span>
</code></pre></div></div>

<p>Python:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">Rect</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">length</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">length</span>


<span class="n">square</span> <span class="o">=</span> <span class="n">Square</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">square</span><span class="p">.</span><span class="n">circ</span><span class="p">()</span> <span class="o">==</span> <span class="mi">20</span>
<span class="k">assert</span> <span class="n">square</span><span class="p">.</span><span class="n">area</span><span class="p">()</span> <span class="o">==</span> <span class="mi">25</span>
</code></pre></div></div>

<h5 id="p65-show-that-a--a--2--a-holds-for-types-up-to-isomorphism-remember-that-2-corresponds-to-bool-according-to-our-translation-table">p6.5 Show that <code class="language-plaintext highlighter-rouge">a + a = 2 * a</code> holds for types (up to isomorphism). Remember that <code class="language-plaintext highlighter-rouge">2</code> corresponds to <code class="language-plaintext highlighter-rouge">Bool</code>, according to our translation table.</h5>
<p><em>Solution</em>
<code class="language-plaintext highlighter-rouge">a + a</code> is equivalent to <code class="language-plaintext highlighter-rouge">Either a a</code> and <code class="language-plaintext highlighter-rouge">2 * a</code> is equivalent to <code class="language-plaintext highlighter-rouge">(Bool, a)</code>. We can define the following invertible functions between them.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aPlusAToTwoTimesA</span> <span class="o">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">aPlusAToTwoTimesA</span> <span class="n">eitherAA</span> <span class="o">=</span>
  <span class="kr">case</span> <span class="n">eitherAA</span> <span class="kr">of</span>
    <span class="kt">Left</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="kt">Right</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

<span class="n">twoTimesAToAPlusA</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">a</span>
<span class="n">twoTimesAToAPlusA</span> <span class="n">twoTimesA</span> <span class="o">=</span>
  <span class="kr">case</span> <span class="n">twoTimesA</span> <span class="kr">of</span>
    <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Left</span> <span class="n">a</span>
    <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Right</span> <span class="n">a</span>
</code></pre></div></div>
<h1 id="section-7-functors">Section 7: Functors</h1>

<h5 id="p71-can-we-turn-the-maybe-type-constructor-into-a-functor-by-defining-fmap-_-_--nothing-which-ignores-both-of-its-arguments-hint-check-the-functor-laws">p7.1 Can we turn the <code class="language-plaintext highlighter-rouge">Maybe</code> type constructor into a functor by defining: <code class="language-plaintext highlighter-rouge">fmap _ _ = Nothing</code> which ignores both of its arguments? (Hint: Check the functor laws.)</h5>
<p><em>Solution</em>
No, this mapping of morphisms does not preserve the identity. For some <code class="language-plaintext highlighter-rouge">Just a</code>, we see that:</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">fmap</span> <span class="n">id</span><span class="p">)</span> <span class="kt">Just</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span>
<span class="n">id</span> <span class="kt">Just</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">a</span>
</code></pre></div></div>

<h5 id="p72-prove-functor-laws-for-the-reader-functor-hint-its-really-simple">p7.2 Prove functor laws for the <code class="language-plaintext highlighter-rouge">reader</code> functor. Hint: it’s really simple.</h5>
<p><em>Solution</em>
We need to use equational reasoning to prove that fmap maintains identity and preserves composition</p>

<p><strong>Identity</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap id (a-&gt;b) =
    (.) id (a-&gt;b) =
    id (a-&gt;b)
</code></pre></div></div>

<p><strong>Composition</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap ((c-&gt;d) . (b-&gt;c)) (a-&gt;b) =
  (c-&gt;d) . (b-&gt;c) . (a-&gt;b) =
  (c-&gt;d) . fmap ((b-&gt;c) (a-&gt;b)) =
  fmap (c-&gt;d) (fmap (b-&gt;c) (a-&gt;b))
</code></pre></div></div>

<h5 id="p73-implement-the-reader-functor-in-your-second-favorite-language-the-first-being-haskell-of-course">p7.3 Implement the <code class="language-plaintext highlighter-rouge">reader</code> functor in your second favorite language (the first being Haskell, of course).</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reader_functor_fmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">r_to_a</span><span class="p">):</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">r_to_a</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">r_to_0</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
  <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">r_to_1</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
  <span class="k">return</span> <span class="mi">1</span>

<span class="n">r_to_5</span> <span class="o">=</span> <span class="n">reader_functor_fmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">r_to_0</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">r_to_0</span><span class="p">(</span><span class="s">"r"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="k">assert</span> <span class="n">r_to_1</span><span class="p">(</span><span class="s">"r"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">r_to_5</span><span class="p">(</span><span class="s">"r"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div></div>

<h5 id="p74-prove-the-functor-laws-for-the-list-functor-assume-that-the-laws-are-true-for-the-tail-part-of-the-list-youre-applying-it-to-in-other-words-use-induction">p7.4 Prove the functor laws for the <code class="language-plaintext highlighter-rouge">list</code> functor. Assume that the laws are true for the tail part of the <code class="language-plaintext highlighter-rouge">list</code> you’re applying it to (in other words, use induction).</h5>
<p><em>Solution</em></p>

<p><strong>Base Case</strong></p>
<ul>
  <li><strong>Identity</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap id Nil = Nil = id Nil
</code></pre></div>    </div>
  </li>
  <li><strong>Composition</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap (f . g) Nil = Nil = fmap f (Nil) = fmap f (fmap g Nil)
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>Inductive Step</strong></p>
<ul>
  <li><strong>Identity</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap id (Cons x t) =
    Cons (id x) (fmap id t)) =
    Cons (id x) (id t)) =
    Cons (x t) =
    id Cons (x t)
</code></pre></div>    </div>
  </li>
  <li><strong>Composition</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap (f . g) (Cons x t)
    = Cons ((f . g) x) (fmap (f . g) t))  // definition of fmap
    = Cons ((f . g) x) ((fmap f . fmap g) t) // induction
    = fmap f (Cons (g x) (fmap g t)) // definition of fmap
    = fmap f (fmap g (Cons (x t))) // definition of fmap
    = (fmap f . fmap g) (Cons (x t))
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="section-8-functorality">Section 8: Functorality</h1>

<h5 id="p81-show-that-the-data-type-data-pair-a-b--pair-a-b-is-a-bifunctor-for-additional-credit-implement-all-three-methods-of-bifunctor-and-use-equational-reasoning-to-show-that-these-definitions-are-compatible-with-the-default-implementations-whenever-they-can-be-applied">p8.1 Show that the data type: <code class="language-plaintext highlighter-rouge">data Pair a b = Pair a b</code> is a bifunctor. For additional credit implement all three methods of <code class="language-plaintext highlighter-rouge">Bifunctor</code> and use equational reasoning to show that these definitions are compatible with the default implementations whenever they can be applied.</h5>
<p><em>Solution</em>
Say we keep one of the arguments constant, then the fmap for both sides is just:</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmap</span> <span class="n">f</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="kt">C</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">C</span><span class="p">)</span>
</code></pre></div></div>
<p><strong>Identity</strong></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmap</span> <span class="n">id</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="kt">C</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="n">id</span> <span class="n">a</span> <span class="kt">C</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="kt">C</span>
</code></pre></div></div>
<p><strong>Composition</strong></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmap</span> <span class="n">f</span><span class="o">*</span><span class="n">g</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="kt">C</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="n">f</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="kt">C</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Pair</span> <span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="kt">C</span>  <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">fmap</span> <span class="n">g</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">c</span>
</code></pre></div></div>

<p>The three methods of Bifunctor</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">pairBimap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Pair</span> <span class="n">c</span> <span class="n">d</span>
<span class="n">pairBimap</span> <span class="n">g</span> <span class="n">h</span> <span class="p">(</span><span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">g</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">h</span> <span class="n">b</span><span class="p">)</span>

<span class="n">pairFirst</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Pair</span> <span class="n">c</span> <span class="n">b</span>
<span class="n">pairFirst</span> <span class="n">g</span> <span class="p">(</span><span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">g</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span>

<span class="n">pairSecond</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">d</span>
<span class="n">pairSecond</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>Proof that these definitions are compatible with the default implementations whenever they can be applied.</p>

<p>Proof of <code class="language-plaintext highlighter-rouge">pairBimap</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(pairBimap g h) (Pair a b) =
  Pair (g a) (h b) // definition of pairBimap
  pairFirst g (Pair a (h b)) // definition of pairFirst
  (pairFirst g . pairSecond h) (Pair a b) // definition of pairSecond
</code></pre></div></div>
<p>Which means that</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pairBimap g h = pairFirst g . pairSecond h
</code></pre></div></div>

<p>Proof of <code class="language-plaintext highlighter-rouge">pairFirst</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pairFirst g (Pair a b) =
  Pair (g a) b // definition of pairFirst
  Pair (g a) (id b) // definition of id
  pairBimap (g id) Pair a b // definition of pairBimap
</code></pre></div></div>
<p>Which means that</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pairFirst g = pairBimap g id
</code></pre></div></div>

<p>Proof of <code class="language-plaintext highlighter-rouge">pairSecond</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pairSecond f (Pair a b) =
  Pair a (f b) // definition of pairSecond
  Pair (id a) (f b) // definition of id
  pairBimap (id f) Pair a b // definition of pairBimap
</code></pre></div></div>
<p>Which means that</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pairSecond = pairBimap id
</code></pre></div></div>

<h5 id="p82-show-the-isomorphism-between-the-standard-definition-of-maybe-and-this-desugaring-type-maybe-a--either-const--a-identity-a-hint-define-two-mappings-between-the-two-implementations-for-additional-credit-show-that-they-are-the-inverse-of-each-other-using-equational-reasoning">p8.2 Show the isomorphism between the standard definition of <code class="language-plaintext highlighter-rouge">Maybe</code> and this desugaring: <code class="language-plaintext highlighter-rouge">type Maybe' a = Either (Const () a) (Identity a)</code> Hint: Define two mappings between the two implementations. For additional credit, show that they are the inverse of each other using equational reasoning.</h5>
<p><em>Solution</em></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">MyIdentity</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">MyIdentity</span> <span class="n">a</span>
<span class="kr">data</span> <span class="kt">MyConst</span> <span class="n">c</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">MyConst</span> <span class="n">c</span>
<span class="kr">type</span> <span class="kt">Maybe'</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Either</span> <span class="p">(</span><span class="kt">MyConst</span> <span class="nb">()</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">MyIdentity</span> <span class="n">a</span><span class="p">)</span>

<span class="n">desugaredToMaybe</span> <span class="o">::</span> <span class="kt">Maybe'</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">desugaredToMaybe</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="kt">MyConst</span> <span class="nb">()</span><span class="p">))</span> <span class="o">=</span>  <span class="kt">Nothing</span>
<span class="n">desugaredToMaybe</span> <span class="p">(</span><span class="kt">Right</span> <span class="p">(</span><span class="kt">MyIdentity</span> <span class="n">a</span><span class="p">))</span> <span class="o">=</span>  <span class="kt">Just</span> <span class="n">a</span>

<span class="n">maybeToDesugared</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe'</span> <span class="n">a</span>
<span class="n">maybeToDesugared</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="kt">MyConst</span> <span class="nb">()</span><span class="p">)</span>
<span class="n">maybeToDesugared</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="kt">MyIdentity</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>We show that they are the inverse of each other using equational reasoning</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>maybeToDesugared desugaredToMaybe (Left (MyConst ()))
  = maybeToDesugared Nothing
  = maybeToDesugared Left (MyConst ())

desugaredToMaybe maybeToDesugared Nothing
  = desugaredToMaybe (Left (MyConst ()))
  = Nothing

maybeToDesugared desugaredToMaybe (Right (MyIdentity a))
  = maybeToDesugared Just a
  = Right (MyIdentity a)

desugaredToMaybe maybeToDesugared Just a
  = desugaredToMaybe Right (MyIdentity a)
  = Just a
</code></pre></div></div>

<h5 id="p83-lets-try-another-data-structure-i-call-it-a-prelist-because-its-a-precursor-to-a-list-it-replaces-recursion-with-a-type-parameter-b-data-prelist-a-b--nil--cons-a-b-you-could-recover-our-earlier-definition-of-a-list-by-recursively-applying-prelist-to-itself-well-see-how-its-done-when-we-talk-about-fixed-points-show-that-prelist-is-an-instance-of-bifunctor">p8.3 Let’s try another data structure. I call it a <code class="language-plaintext highlighter-rouge">PreList</code> because it’s a precursor to a List. It replaces recursion with a type parameter <code class="language-plaintext highlighter-rouge">b</code>: <code class="language-plaintext highlighter-rouge">data PreList a b = Nil | Cons a b</code>. You could recover our earlier definition of a <code class="language-plaintext highlighter-rouge">List</code> by recursively applying <code class="language-plaintext highlighter-rouge">PreList</code> to itself (we’ll see how it’s done when we talk about fixed points). Show that <code class="language-plaintext highlighter-rouge">PreList</code> is an instance of <code class="language-plaintext highlighter-rouge">Bifunctor</code>.</h5>
<p><em>Solution</em>
Lets form the following mapping</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmapFull</span><span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">PreList</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">PreList</span> <span class="n">c</span> <span class="n">d</span><span class="p">)</span>
<span class="n">fmapFull</span> <span class="n">f</span> <span class="n">g</span> <span class="kt">Nil</span> <span class="o">=</span> <span class="kt">Nil</span>
<span class="n">fmapFull</span> <span class="n">f</span> <span class="n">g</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Cons</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>Say we keep <code class="language-plaintext highlighter-rouge">b</code> constant (WLOG). Then the <code class="language-plaintext highlighter-rouge">fmap</code> for <code class="language-plaintext highlighter-rouge">a</code> is</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nil</span> <span class="o">=</span> <span class="kt">Nil</span>
<span class="n">fmap</span> <span class="n">f</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="kt">C</span> <span class="o">=</span> <span class="kt">Cons</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="kt">C</span>
</code></pre></div></div>
<p>This is a functor because
<strong>Identity</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap id Nil = Nil
fmap id Cons a C = Cons id a C = Cons a C
</code></pre></div></div>
<p><strong>Composition</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap f . g Nil = Nil
fmap f . g Cons a C =
    Cons f . g a C =
    fmap f Cons g a C =
    fmap f (fmap g Cons a C)
</code></pre></div></div>

<h5 id="p84-show-that-the-following-data-types-define-bifunctors-in-a-and-b">p8.4 Show that the following data types define bifunctors in <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>:</h5>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">K2</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">K2</span> <span class="n">c</span>
<span class="kr">data</span> <span class="kt">Fst</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Fst</span> <span class="n">a</span>
<span class="kr">data</span> <span class="kt">Snd</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Snd</span> <span class="n">b</span>
</code></pre></div></div>
<h5 id="for-additional-credit-check-your-solutions-agains-conor-mcbrides-paper-clowns-to-the-left-of-me-jokers-to-the-right">For additional credit, check your solutions agains Conor McBride’s paper Clowns to the Left of me, Jokers to the Right.</h5>
<p><em>Solution</em></p>

<p><code class="language-plaintext highlighter-rouge">K2</code>:
Without loss of generality, if we hold <code class="language-plaintext highlighter-rouge">b</code> constant, then <code class="language-plaintext highlighter-rouge">K2</code> becomes <code class="language-plaintext highlighter-rouge">Const</code>, which is a functor</p>

<p><code class="language-plaintext highlighter-rouge">Fst</code>:
If we hold <code class="language-plaintext highlighter-rouge">a</code> constant, then <code class="language-plaintext highlighter-rouge">Fst</code> becomes <code class="language-plaintext highlighter-rouge">Const</code>, which is a functor
If we hold <code class="language-plaintext highlighter-rouge">b</code> constant, then <code class="language-plaintext highlighter-rouge">Fst</code> becomes <code class="language-plaintext highlighter-rouge">Identity</code>, which is a functor</p>

<p><code class="language-plaintext highlighter-rouge">Snd</code>:
If we hold <code class="language-plaintext highlighter-rouge">a</code> constant, then <code class="language-plaintext highlighter-rouge">Snd</code> becomes <code class="language-plaintext highlighter-rouge">Identity</code>, which is a functor
If we hold <code class="language-plaintext highlighter-rouge">b</code> constant, then <code class="language-plaintext highlighter-rouge">Snd</code> becomes <code class="language-plaintext highlighter-rouge">Const</code>, which is a functor</p>

<h5 id="p85-define-a-bifunctor-in-a-language-other-than-haskell-implement-bimap-for-a-generic-pair-in-that-language">p8.5 Define a bifunctor in a language other than Haskell. Implement <code class="language-plaintext highlighter-rouge">bimap</code> for a generic pair in that language.</h5>
<p><em>Solution</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Bifunctor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">apply_bimap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="k">assert</span> <span class="bp">False</span>

  <span class="o">@</span><span class="nb">classmethod</span>
  <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">.</span><span class="n">apply_bimap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>

  <span class="o">@</span><span class="nb">classmethod</span>
  <span class="k">def</span> <span class="nf">second</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">.</span><span class="n">apply_bimap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

  <span class="o">@</span><span class="nb">classmethod</span>
  <span class="k">def</span> <span class="nf">bimap</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">.</span><span class="n">apply_bimap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Bifunctor</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aval</span><span class="p">,</span> <span class="n">bval</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">aval</span> <span class="o">=</span> <span class="n">aval</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">bval</span> <span class="o">=</span> <span class="n">bval</span>

  <span class="k">def</span> <span class="nf">apply_bimap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Pair</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">aval</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">bval</span><span class="p">))</span>


<span class="n">p</span> <span class="o">=</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">"4"</span><span class="p">)</span>
<span class="n">first_mapped</span> <span class="o">=</span> <span class="n">Bifunctor</span><span class="p">.</span><span class="n">first</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)(</span><span class="n">p</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">first_mapped</span><span class="p">.</span><span class="n">aval</span> <span class="o">==</span> <span class="mi">6</span>
<span class="k">assert</span> <span class="n">first_mapped</span><span class="p">.</span><span class="n">bval</span> <span class="o">==</span> <span class="s">"4"</span>

<span class="n">second_mapped</span> <span class="o">=</span> <span class="n">Bifunctor</span><span class="p">.</span><span class="n">second</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="s">"1"</span><span class="p">)(</span><span class="n">p</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">second_mapped</span><span class="p">.</span><span class="n">aval</span> <span class="o">==</span> <span class="mi">5</span>
<span class="k">assert</span> <span class="n">second_mapped</span><span class="p">.</span><span class="n">bval</span> <span class="o">==</span> <span class="s">"41"</span>

<span class="n">bimapped</span> <span class="o">=</span> <span class="n">Bifunctor</span><span class="p">.</span><span class="n">bimap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"1"</span><span class="p">)(</span><span class="n">p</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">bimapped</span><span class="p">.</span><span class="n">aval</span>
</code></pre></div></div>

<h5 id="p86-should-stdmap-be-considered-a-bifunctor-or-a-profunctor-in-the-two-template-arguments-key-and-t-how-would-you-redesign-this-data-type-to-make-it-so">p8.6 Should <code class="language-plaintext highlighter-rouge">std::map</code> be considered a bifunctor or a profunctor in the two template arguments <code class="language-plaintext highlighter-rouge">Key</code> and <code class="language-plaintext highlighter-rouge">T</code>? How would you redesign this data type to make it so?</h5>
<p><em>Solution</em>
<code class="language-plaintext highlighter-rouge">std::map</code> should be considered a profunctor in <code class="language-plaintext highlighter-rouge">Key</code> and <code class="language-plaintext highlighter-rouge">T</code>.</p>

<p>We can define it as a Profunctor as follows:</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="kt">Profunctor</span> <span class="n">get</span> <span class="kr">where</span>
  <span class="n">dimap</span> <span class="n">f</span> <span class="n">g</span> <span class="n">get</span> <span class="o">=</span> <span class="n">lmap</span> <span class="n">f</span> <span class="o">.</span> <span class="n">rmap</span> <span class="n">g</span>
  <span class="n">lmap</span> <span class="n">f</span> <span class="n">get</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">get</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">rmap</span> <span class="n">g</span> <span class="n">get</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">g</span> <span class="p">(</span><span class="n">get</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="section-9-function-types-no-challenges">Section 9: Function Types (No Challenges)</h1>
<h1 id="section-10-natural-transformations">Section 10: Natural Transformations</h1>

<h5 id="p101-define-a-natural-transformation-from-the-maybe-functor-to-the-list-functor-prove-the-naturality-condition-for-it">p10.1 Define a natural transformation from the <code class="language-plaintext highlighter-rouge">Maybe</code> functor to the <code class="language-plaintext highlighter-rouge">list</code> functor. Prove the naturality condition for it.</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">natTrans</span><span class="o">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">natTrans</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="n">natTrans</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">[]</span>
</code></pre></div></div>

<p>The naturality condition is <code class="language-plaintext highlighter-rouge">G f ◦ αa = αb ◦ F f</code>, which translates to  <code class="language-plaintext highlighter-rouge">fmap_list f . natTrans = natTrans . fmap_maybe f</code></p>

<p><code class="language-plaintext highlighter-rouge">Nothing</code> Case:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap_list f . natTrans Nothing =
  fmap_list f [] =
  [] =
  natTrans Nothing =
  natTrans . fmap_maybe f Nothing
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">(Just x)</code> Case:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap_list f . natTrans (Just x) =
  fmap_list f [x] =
  [f(x)] =
  natTrans (Just (f x)) =  
  natTrans . fmap_maybe f (Just x)
</code></pre></div></div>

<h5 id="p102-define-at-least-two-different-natural-transformations-between-reader--and-the-list-functor-how-many-different-lists-of--are-there">p10.2 Define at least two different natural transformations between <code class="language-plaintext highlighter-rouge">Reader ()</code> and the <code class="language-plaintext highlighter-rouge">list</code> functor. How many different lists of <code class="language-plaintext highlighter-rouge">()</code> are there?</h5>
<p><em>Solution</em></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">natTransRL1</span><span class="o">::</span> <span class="p">(</span><span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">natTransRL1</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>

<span class="n">natTransRL2</span><span class="o">::</span> <span class="p">(</span><span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">natTransRL2</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="nb">()</span><span class="p">]</span>

<span class="n">natTransRL3</span><span class="o">::</span> <span class="p">(</span><span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">natTransRL3</span> <span class="n">g</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">g</span> <span class="p">[</span><span class="nb">()</span><span class="p">,</span> <span class="nb">()</span><span class="p">]</span>
</code></pre></div></div>

<p>Since there are an infinite number of lists of <code class="language-plaintext highlighter-rouge">[(), ...]</code>, there are an infinite number of these natural transformations.</p>

<h5 id="p103-continue-the-previous-exercise-with-reader-bool-and-maybe">p10.3 Continue the previous exercise with <code class="language-plaintext highlighter-rouge">Reader Bool</code> and <code class="language-plaintext highlighter-rouge">Maybe</code>.</h5>
<p><em>Solution</em></p>

<p>There are three natural transformations from <code class="language-plaintext highlighter-rouge">Reader Bool -&gt; Maybe</code></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">natTransRB1</span><span class="o">::</span> <span class="p">(</span><span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">natTransRB1</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span>

<span class="n">natTransRB2</span><span class="o">::</span> <span class="p">(</span><span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">natTransRB2</span> <span class="n">g</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">g</span> <span class="kt">True</span><span class="p">)</span>

<span class="n">natTransRB3</span><span class="o">::</span> <span class="p">(</span><span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">natTransRB3</span> <span class="n">g</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">g</span> <span class="kt">False</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="p104-show-that-horizontal-composition-of-natural-transformation-satisfies-the-naturality-condition-hint-use-components-its-a-good-exercise-in-diagram-chasing">p10.4 Show that horizontal composition of natural transformation satisfies the naturality condition (hint: use components). It’s a good exercise in diagram chasing.</h5>
<p><em>Solution</em></p>

<p>We have the functors <code class="language-plaintext highlighter-rouge">F, G</code> and the natural transformations:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>αa:: F a -&gt; F'a
βa:: G a -&gt; G'a
</code></pre></div></div>

<p>We need to show that <code class="language-plaintext highlighter-rouge">(G' . F') f . (β ◦ α)a = (β ◦ α)b . (G . F) f</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(β ◦ α)b . (G . F) f =
  (βF'b . Gαb) . G . F f = // definition of horizontal composition
   βF'b . G  . F' f . αa = // G αb :: G (F b) -&gt; G (F'b)
  (G' . F') f . (β ◦ α)a = // βF'b :: G (F'a) -&gt; G'(F'a)
</code></pre></div></div>

<h5 id="p105-write-a-short-essay-about-how-you-may-enjoy-writing-down-the-evident-diagrams-needed-to-prove-the-interchange-law">p10.5 Write a short essay about how you may enjoy writing down the evident diagrams needed to prove the interchange law.</h5>
<p><em>Solution</em></p>

<p>If it’s the case that:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F -β'-&gt; F'
F' -α'-&gt; F''

G -β-&gt; G'
G' -α-&gt; G''
</code></pre></div></div>
<p>Then by the definition of horizontal composition it’s simple to see that:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FG -(β' ◦ β)-&gt; F'G' -(α' ◦ α)-&gt; F''G''
FG -(β' . α') ◦ (β . α)-&gt; F''G''
</code></pre></div></div>
<p>Also, by horizontal composition:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FG -(β' ◦ β)-&gt; F'G'
F'G' -(α' ◦ α)-&gt; F''G''
FG -(β' ◦ β) . (α' ◦ α)-&gt; F''G''
</code></pre></div></div>
<p>so <code class="language-plaintext highlighter-rouge">(β' ◦ β) . (α' ◦ α)</code> and <code class="language-plaintext highlighter-rouge">(β' . α') ◦ (β . α)</code> have the equivalent effect on <code class="language-plaintext highlighter-rouge">FG</code></p>

<h5 id="p106-create-a-few-test-cases-for-the-opposite-naturality-condition-of-transformations-between-different-op-functors-heres-one-choice">p10.6 Create a few test cases for the opposite naturality condition of transformations between different <code class="language-plaintext highlighter-rouge">Op</code> functors. Here’s one choice:</h5>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">op</span> <span class="o">::</span> <span class="kt">Op</span> <span class="kt">Bool</span> <span class="kt">Int</span>
<span class="n">op</span> <span class="o">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">and</span>
<span class="n">f</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">read</span> <span class="n">x</span>
</code></pre></div></div>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">newtype</span> <span class="kt">Op</span> <span class="n">r</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="p">)</span>
<span class="n">contramap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="n">g</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>

<span class="n">unwrap_op</span> <span class="o">::</span> <span class="kt">Op</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">unwrap_op</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">f</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>

<span class="c1">-- test 1</span>
<span class="n">op1</span> <span class="o">::</span> <span class="kt">Op</span> <span class="kt">Bool</span> <span class="kt">Int</span>
<span class="n">op1</span> <span class="o">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>

<span class="n">f1</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">f1</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span>

<span class="n">opBoolToOpChar</span> <span class="o">::</span> <span class="kt">Op</span> <span class="kt">Bool</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Op</span> <span class="kt">Char</span> <span class="n">a</span>
<span class="n">opBoolToOpChar</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">aToBool</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">aToBool</span> <span class="n">x</span> <span class="kr">then</span> <span class="sc">'a'</span> <span class="kr">else</span> <span class="sc">'b'</span><span class="p">)</span>

<span class="n">boolchar_contra_f_op1</span> <span class="o">::</span> <span class="kt">Op</span> <span class="kt">Char</span> <span class="kt">Bool</span>
<span class="n">boolchar_contra_f_op1</span> <span class="o">=</span> <span class="n">opBoolToOpChar</span> <span class="p">((</span><span class="n">contramap</span> <span class="n">f1</span><span class="p">)</span> <span class="n">op1</span><span class="p">)</span>

<span class="n">contra_f_boolchar_op1</span> <span class="o">::</span> <span class="kt">Op</span> <span class="kt">Char</span> <span class="kt">Bool</span>
<span class="n">contra_f_boolchar_op1</span> <span class="o">=</span> <span class="n">contramap</span> <span class="n">f1</span> <span class="p">(</span><span class="n">opBoolToOpChar</span> <span class="n">op1</span><span class="p">)</span>

<span class="n">test1a</span> <span class="o">=</span> <span class="p">(</span><span class="n">unwrap_op</span> <span class="n">boolchar_contra_f_op1</span> <span class="kt">True</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">unwrap_op</span> <span class="n">contra_f_boolchar_op1</span> <span class="kt">True</span><span class="p">)</span>
<span class="n">test1b</span> <span class="o">=</span> <span class="p">(</span><span class="n">unwrap_op</span> <span class="n">boolchar_contra_f_op1</span> <span class="kt">False</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">unwrap_op</span> <span class="n">contra_f_boolchar_op1</span> <span class="kt">False</span><span class="p">)</span>

<span class="c1">-- test 2</span>
<span class="n">op2</span> <span class="o">::</span> <span class="kt">Op</span> <span class="kt">String</span> <span class="kt">Double</span>
<span class="n">op2</span> <span class="o">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">x</span><span class="p">)</span>

<span class="n">f2</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
<span class="n">f2</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">x</span><span class="p">)</span>

<span class="n">opStringToOpInt</span> <span class="o">::</span> <span class="kt">Op</span> <span class="kt">String</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Op</span> <span class="kt">Int</span> <span class="n">a</span>
<span class="n">opStringToOpInt</span> <span class="p">(</span><span class="kt">Op</span> <span class="n">aToString</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Op</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">length</span> <span class="p">(</span><span class="n">aToString</span> <span class="n">x</span><span class="p">))</span>

<span class="n">stringint_contra_f_op2</span> <span class="o">::</span> <span class="kt">Op</span> <span class="kt">Int</span> <span class="kt">Int</span>
<span class="n">stringint_contra_f_op2</span> <span class="o">=</span> <span class="n">opStringToOpInt</span> <span class="p">((</span><span class="n">contramap</span> <span class="n">f2</span><span class="p">)</span> <span class="n">op2</span><span class="p">)</span>

<span class="n">contra_f_stringint_op2</span> <span class="o">::</span> <span class="kt">Op</span> <span class="kt">Int</span> <span class="kt">Int</span>
<span class="n">contra_f_stringint_op2</span> <span class="o">=</span> <span class="n">contramap</span> <span class="n">f2</span> <span class="p">(</span><span class="n">opStringToOpInt</span> <span class="n">op2</span><span class="p">)</span>

<span class="n">test2a</span> <span class="o">=</span> <span class="p">(</span><span class="n">unwrap_op</span> <span class="n">stringint_contra_f_op2</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">unwrap_op</span> <span class="n">contra_f_stringint_op2</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">test2b</span> <span class="o">=</span> <span class="p">(</span><span class="n">unwrap_op</span> <span class="n">stringint_contra_f_op2</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">unwrap_op</span> <span class="n">contra_f_stringint_op2</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="section-11-declarative-programming-no-challenges">Section 11: Declarative Programming (No Challenges)</h1>

<h1 id="section-12-limits-and-colimits">Section 12: Limits and Colimits</h1>

<h5 id="p121-how-would-you-describe-a-pushout-in-the-category-of-c-classes">p12.1 How would you describe a pushout in the category of C++ classes?</h5>
<p><em>Solution</em>
We are working in the C++ types category with subclasses as morphisms. For the span <code class="language-plaintext highlighter-rouge">1 &lt;- 2 -&gt; 3</code> we have a class 2 that inherits from 1 and 3, and since we are working with colimits, the apex is some 4 such that <code class="language-plaintext highlighter-rouge">1 -&gt; 4 &lt;- 3</code>. The pushout is the colimit of this diagram, which is the universal 4 such that the colimit is also the subclass of every other candidate. This is the class 4 that has the maximum amount of shared functionality such that it can still be a superclass of 1 and 3.</p>

<h5 id="p122-show-that-the-limit-of-the-identity-functor-id--c---c-is-the-initial-object">p12.2 Show that the limit of the identity functor <code class="language-plaintext highlighter-rouge">Id :: C -&gt; C</code> is the initial object.</h5>
<p><em>Solution</em>
The identity functor forms diagrams consisting of every item in C. The apex of each diagram must have morphisms to every other item, and the limit object must have unique morphisms to every other limit candidate, which is every other item. Therefore the limit must be the initial object.</p>

<h5 id="p123-subsets-of-a-given-set-form-a-category-a-morphism-in-that-category-is-defined-to-be-an-arrow-connecting-two-sets-if-the-first-is-the-subset-of-the-second-what-is-a-pullback-of-two-sets-in-such-a-category-whats-a-pushout-what-are-the-initial-and-terminal-objects">p12.3 Subsets of a given set form a category. A morphism in that category is defined to be an arrow connecting two sets if the first is the subset of the second. What is a pullback of two sets in such a category? What’s a pushout? What are the initial and terminal objects?</h5>
<p><em>Solution</em>
The pushout is the intersection of the two sets (the largest set contained in them both) and the pullback is the union of those sets (the smallest set that contains them both). The initial object is the empty set and the terminal object is the “given set” that contains all of the elements and that all of the other elements are subsets of.</p>

<h5 id="p124-can-you-guess-what-a-coequalizer-is">p12.4 Can you guess what a coequalizer is?</h5>
<p><em>Solution</em>
The coequalizer is the equalizer in the opposite category. Given some 2 morphisms <code class="language-plaintext highlighter-rouge">f: b -&gt; a</code> and <code class="language-plaintext highlighter-rouge">g: b -&gt; a</code>, the coequalizer is the colimit object <code class="language-plaintext highlighter-rouge">c</code> and associated morphism <code class="language-plaintext highlighter-rouge">p: a -&gt; c</code> such that <code class="language-plaintext highlighter-rouge">p . f = p . g</code>. That is, for any other <code class="language-plaintext highlighter-rouge">c'</code> with morphism <code class="language-plaintext highlighter-rouge">p'</code> there exists some <code class="language-plaintext highlighter-rouge">u</code> such that <code class="language-plaintext highlighter-rouge">p' = p . u</code>.</p>

<p>Over Set, the coequalizer defines a transformation of f and g’s codomains that makes them equal to each other.</p>

<h5 id="p125-show-that-in-a-category-with-a-terminal-object-a-pullback-towards-the-terminal-object-is-a-product">p12.5 Show that, in a category with a terminal object, a pullback towards the terminal object is a product.</h5>
<p><em>Solution</em>
Consider a diagram formed by the three object category <code class="language-plaintext highlighter-rouge">I</code> of the form <code class="language-plaintext highlighter-rouge">1 -f-&gt; t &lt;-g- 2</code> such that t is the terminal object. Since f and g are unique, the category of such diagrams is isomorphic to the category of diagrams formed by the two object discrete category consisting of only <code class="language-plaintext highlighter-rouge">1,2</code> without morphisms. The limit of this category is the product, so the pullback towards the terminal object is the product.</p>

<h5 id="p126-similarly-show-that-a-pushout-from-an-initial-object-if-one-exists-is-the-coproduct">p12.6 Similarly, show that a pushout from an initial object (if one exists) is the coproduct.</h5>
<p><em>Solution</em>
Consider a diagram formed by the three object category I of the form <code class="language-plaintext highlighter-rouge">1 &lt;-f- i -g-&gt; 2</code> such that <code class="language-plaintext highlighter-rouge">i</code> is the initial object. Since <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">g</code> are unique, the category of such diagrams is isomorphic to the category of diagrams formed by the two object discrete category consisting of only <code class="language-plaintext highlighter-rouge">1,2</code> without morphisms. The colimit of this category is the coproduct, so the pushout towards the initial object is the coproduct.</p>

<h1 id="section-13-free-monoids">Section 13: Free Monoids</h1>

<h5 id="p131-you-might-think-as-i-did-originally-that-the-requirement-that-a-homomorphism-of-monoids-preserve-the-unit-is-redundant-after-all-we-know-that-for-all-a-h-a--h-e--h-a--e--h-a-so-h-e-acts-like-a-right-unit-and-by-analogy-as-a-left-unit-the-problem-is-that-h-a-for-all-a-might-only-cover-a-sub-monoid-of-the-target-monoid-there-may-be-a-true-unit-outside-of-the-image-of-h-show-that-an-isomorphism-between-monoids-that-preserves-multiplication-must-automatically-preserve-unit">p13.1 You might think (as I did, originally) that the requirement that a homomorphism of monoids preserve the unit is redundant. After all, we know that for all <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">h a * h e = h (a * e) = h a</code> So <code class="language-plaintext highlighter-rouge">h e</code> acts like a right unit (and, by analogy, as a left unit). The problem is that <code class="language-plaintext highlighter-rouge">h a</code>, for all <code class="language-plaintext highlighter-rouge">a</code> might only cover a sub-monoid of the target monoid. There may be a “true” unit outside of the image of h. Show that an isomorphism between monoids that preserves multiplication must automatically preserve unit.</h5>
<p><em>Solution</em>
Say <code class="language-plaintext highlighter-rouge">f: A -&gt; A'</code> is a monoid isomorphishm. Then there exists some <code class="language-plaintext highlighter-rouge">g: A' -&gt; A</code> such that <code class="language-plaintext highlighter-rouge">g f a = a</code>. Given the unit <code class="language-plaintext highlighter-rouge">u</code> in <code class="language-plaintext highlighter-rouge">A</code>, for all <code class="language-plaintext highlighter-rouge">a'</code> in <code class="language-plaintext highlighter-rouge">A'</code>, we see <code class="language-plaintext highlighter-rouge">g (a' * f u) = g a' * g f u = g a' * u = g a'</code>. Since <code class="language-plaintext highlighter-rouge">g</code> is injective, this means that <code class="language-plaintext highlighter-rouge">a' = a' * f u</code>, so <code class="language-plaintext highlighter-rouge">f u</code> is the right unit for all <code class="language-plaintext highlighter-rouge">a' in A'</code>. We can do the same to show <code class="language-plaintext highlighter-rouge">f u</code> is the left unit as well.</p>

<h5 id="p132-consider-a-monoid-homomorphism-from-lists-of-integers-with-concatenation-to-integers-with-multiplication-what-is-the-image-of-the-empty-list--assume-that-all-singleton-lists-are-mapped-to-the-integers-they-contain-that-is-3-is-mapped-to-3-etc-whats-the-image-of-1-2-3-4-how-many-different-lists-map-to-the-integer-12-is-there-any-other-homomorphism-between-the-two-monoids">p13.2 Consider a monoid homomorphism from lists of integers with concatenation to integers with multiplication. What is the image of the empty list <code class="language-plaintext highlighter-rouge">[]</code>? Assume that all singleton lists are mapped to the integers they contain, that is <code class="language-plaintext highlighter-rouge">[3]</code> is mapped to <code class="language-plaintext highlighter-rouge">3</code>, etc. What’s the image of <code class="language-plaintext highlighter-rouge">[1, 2, 3, 4]</code>? How many different lists map to the integer 12? Is there any other homomorphism between the two monoids?</h5>
<p><em>Solution</em>
The image of the empty list is <code class="language-plaintext highlighter-rouge">1</code>, and the image of <code class="language-plaintext highlighter-rouge">[1,2,3,4]</code> is <code class="language-plaintext highlighter-rouge">1*2*3*4=24</code>. The lists <code class="language-plaintext highlighter-rouge">[12,1] [1,12] [6,2] [2,6] [3,4] [4,3] [2,2,3] [2,3,2] [3,2,2]</code> all map to <code class="language-plaintext highlighter-rouge">12</code>.</p>

<p>The function that maps all lists of integers to <code class="language-plaintext highlighter-rouge">1</code> is also a homomorphism, because the unit <code class="language-plaintext highlighter-rouge">[1]</code> is preserved and for any two lists <code class="language-plaintext highlighter-rouge">l1,l2</code> we see that <code class="language-plaintext highlighter-rouge">h (l1 ++ l2) = 1 = 1 * 1 = h l1 * h l2</code></p>

<h5 id="p133-what-is-the-free-monoid-generated-by-a-one-element-set-can-you-see-what-its-isomorphic-to">p13.3 What is the free monoid generated by a one-element set? Can you see what it’s isomorphic to?</h5>
<p><em>Solution</em>
This monoid is lists of unit <code class="language-plaintext highlighter-rouge">()</code> with concatenation. This is isomorphic to integers over addition.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">forward</span> <span class="o">::</span> <span class="kt">List</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">forward</span> <span class="n">x</span> <span class="o">=</span> <span class="n">length</span> <span class="n">x</span>

<span class="n">inverse</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">List</span> <span class="nb">()</span>
<span class="n">inverse</span> <span class="n">x</span> <span class="o">=</span> <span class="n">replicate</span> <span class="n">x</span> <span class="p">[</span><span class="nb">()</span><span class="p">]</span>
</code></pre></div></div>

<h1 id="section-14-representable-functors">Section 14: Representable Functors</h1>

<h5 id="p141-show-that-the-hom-functors-map-identity-morphisms-in-c-to-corresponding-identity-functions-in-set">p14.1 Show that the hom-functors map identity morphisms in <code class="language-plaintext highlighter-rouge">C</code> to corresponding identity functions in <code class="language-plaintext highlighter-rouge">Set</code>.</h5>
<p><em>Solution</em>
When we apply the functor <code class="language-plaintext highlighter-rouge">C(a, -)</code> to some function <code class="language-plaintext highlighter-rouge">f</code>, we get a function that performs the action <code class="language-plaintext highlighter-rouge">C (a, f) h = f . h</code> on any morphism <code class="language-plaintext highlighter-rouge">h: a -&gt; x</code> in the homset <code class="language-plaintext highlighter-rouge">Hom(a, x)</code>. If <code class="language-plaintext highlighter-rouge">f: x -&gt; x</code> is the identity morphism, <code class="language-plaintext highlighter-rouge">f . h = h</code>, so <code class="language-plaintext highlighter-rouge">C (a, f) h = h</code>, and <code class="language-plaintext highlighter-rouge">C (a, f)</code> is the identity morphism as well.</p>

<h5 id="p142-show-that-maybe-is-not-representable">p14.2 Show that <code class="language-plaintext highlighter-rouge">Maybe</code> is not representable.</h5>
<p><em>Solution</em>
If Maybe were representable, then we would be able to implement a function of the for <code class="language-plaintext highlighter-rouge">beta :: Maybe x -&gt; (a -&gt; x)</code>. However, it is not possible to implement a function that accepts <code class="language-plaintext highlighter-rouge">None</code> and return <code class="language-plaintext highlighter-rouge">a -&gt; x</code> for any arbitrary <code class="language-plaintext highlighter-rouge">x</code> type.</p>

<h5 id="p143-is-the-reader-functor-representable">p14.3 Is the <code class="language-plaintext highlighter-rouge">Reader</code> functor representable?</h5>
<p><em>Solution</em>
Yes, the <code class="language-plaintext highlighter-rouge">Reader</code> functor is the hom-functor over haskell types and it is isomorphic to itself.</p>

<h5 id="p144-using-stream-representation-memoize-a-function-that-squares-its-argument">p14.4 Using <code class="language-plaintext highlighter-rouge">Stream</code> representation, memoize a function that squares its argument.</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Stream</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Cons</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">x</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">Representable</span> <span class="kt">Stream</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Rep</span> <span class="kt">Stream</span> <span class="o">=</span> <span class="kt">Int</span>
  <span class="n">tabulate</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Cons</span> <span class="p">(</span><span class="n">f</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="n">tabulate</span> <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
  <span class="n">index</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">b</span> <span class="n">bs</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="n">b</span> <span class="kr">else</span> <span class="n">index</span> <span class="n">bs</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">squareArg</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">squareArg</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">memoizedSquares</span> <span class="o">::</span> <span class="kt">Stream</span> <span class="kt">Int</span>
<span class="n">memoizedSquares</span> <span class="o">=</span> <span class="n">tabulate</span> <span class="n">squareArg</span>


<span class="n">zerothSquare</span> <span class="o">::</span> <span class="kt">Int</span>
<span class="n">zerothSquare</span> <span class="o">=</span> <span class="n">index</span> <span class="n">memoizedSquares</span> <span class="mi">0</span>
<span class="n">zerothSquareTrue</span> <span class="o">=</span> <span class="n">zerothSquare</span> <span class="o">==</span> <span class="mi">0</span>

<span class="n">thirdSquare</span> <span class="o">::</span> <span class="kt">Int</span>
<span class="n">thirdSquare</span> <span class="o">=</span> <span class="n">index</span> <span class="n">memoizedSquares</span> <span class="mi">3</span>
<span class="n">thirdSquareTrue</span> <span class="o">=</span> <span class="n">thirdSquare</span> <span class="o">==</span> <span class="mi">9</span>


<span class="n">fifthSquare</span> <span class="o">::</span> <span class="kt">Int</span>
<span class="n">fifthSquare</span> <span class="o">=</span> <span class="n">index</span> <span class="n">memoizedSquares</span> <span class="mi">5</span>
<span class="n">fifthSquareTrue</span> <span class="o">=</span> <span class="n">fifthSquare</span> <span class="o">==</span> <span class="mi">25</span>
</code></pre></div></div>

<h5 id="p145-show-that-tabulate-and-index-for-stream-are-indeed-the-inverse-of-each-other-hint-use-induction">p14.5 Show that <code class="language-plaintext highlighter-rouge">tabulate</code> and <code class="language-plaintext highlighter-rouge">index</code> for <code class="language-plaintext highlighter-rouge">Stream</code> are indeed the inverse of each other. (Hint: use induction.)</h5>
<p><em>Solution</em>
We want to prove that for all <code class="language-plaintext highlighter-rouge">n</code>, <code class="language-plaintext highlighter-rouge">index tabulate f n = f n</code>
<strong>Base Case</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>index (tabulate f) 0 = // definition of tabulate
  index (Cons (f 0) (tabulate (f . (+1)))) 0 = // definition of index
  f 0
</code></pre></div></div>
<p><strong>Inductive Step</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>index (tabulate f) n = // definition of tabulate
  index (Cons (f 0) (tabulate (f . (+1)))) n = // definition of index
  index (tabulate (f . (+1))) (n - 1)  = // inductive assumption
  f . (+1) . (n - 1) =
  f n
</code></pre></div></div>

<h1 id="section-15-the-yoneda-lemma">Section 15: The Yoneda Lemma</h1>

<h5 id="p151-show-that-the-two-functions-phi-and-psi-that-form-the-yoneda-isomorphism-in-haskell-are-inverses-of-each-other">p15.1 Show that the two functions <code class="language-plaintext highlighter-rouge">phi</code> and <code class="language-plaintext highlighter-rouge">psi</code> that form the Yoneda isomorphism in Haskell are inverses of each other.</h5>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">phi</span> <span class="o">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">x</span> <span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">F</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">F</span> <span class="n">a</span>
<span class="n">phi</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="n">id</span>
<span class="n">psi</span> <span class="o">::</span> <span class="kt">F</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">x</span> <span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">F</span> <span class="n">x</span><span class="p">)</span>
<span class="n">psi</span> <span class="n">fa</span> <span class="n">h</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">h</span> <span class="n">fa</span>
</code></pre></div></div>
<p><em>Solution</em>
Note <code class="language-plaintext highlighter-rouge">psi</code> can be written as <code class="language-plaintext highlighter-rouge">psi fa = \h -&gt; fmap h fa</code>
<strong>Forward</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(phi . psi) fa =
  phi (\h -&gt; fmap h fa) =
  (\h -&gt; fmap h fa) id =
  fmap id fa =
  fa
</code></pre></div></div>
<p><strong>Backward</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(psi . phi) alpha =
  psi (alpha id) =
  \h -&gt; fmap h (alpha id) =
  \h -&gt; (alpha h id) =
  \h -&gt; alpha h =
  alpha
</code></pre></div></div>
<h5 id="p152-a-discrete-category-is-one-that-has-objects-but-no-morphisms-other-than-identity-morphisms-how-does-the-yoneda-lemma-work-for-functors-from-such-a-category">p15.2 A discrete category is one that has objects but no morphisms other than identity morphisms. How does the Yoneda lemma work for functors from such a category?</h5>
<p><em>Solution</em>
Any homfunctor <code class="language-plaintext highlighter-rouge">C(a, -)</code> from the discrete category maps <code class="language-plaintext highlighter-rouge">a</code> to the singleton set and all other objects to the empty set. For any functor <code class="language-plaintext highlighter-rouge">F</code> from the discrete category to <code class="language-plaintext highlighter-rouge">Set</code>, there are <code class="language-plaintext highlighter-rouge">N</code> morphisms (the item-selection morphisms) between the singleton set and <code class="language-plaintext highlighter-rouge">F a</code>, where <code class="language-plaintext highlighter-rouge">N</code> is the number of elements of <code class="language-plaintext highlighter-rouge">F a</code>. Since there is one morphism from the empty set to each other set, each of those N morphisms from singleton to <code class="language-plaintext highlighter-rouge">F a</code> indicate a unique natural transformation from <code class="language-plaintext highlighter-rouge">C(a, -)</code> to <code class="language-plaintext highlighter-rouge">F</code>, so there is one-to-one correspondence between these natural transformations and elements of <code class="language-plaintext highlighter-rouge">F a</code>.</p>

<h5 id="p153-a-list-of-units--contains-no-other-information-but-its-length-so-as-a-data-type-it-can-be-considered-an-encoding-of-integers-an-empty-list-encodes-zero-a-singleton--a-value-not-a-type-encodes-one-and-so-on-construct-another-representation-of-this-data-type-using-the-yoneda-lemma-for-the-list-functor">p15.3 A list of units <code class="language-plaintext highlighter-rouge">[()]</code> contains no other information but its length. So, as a data type, it can be considered an encoding of integers. An empty list encodes zero, a singleton <code class="language-plaintext highlighter-rouge">[()]</code> (a value, not a type) encodes one, and so on. Construct another representation of this data type using the Yoneda lemma for the <code class="language-plaintext highlighter-rouge">list</code> functor.</h5>
<p><em>Solution</em>
By the Yoneda lemma, the natural transformations from <code class="language-plaintext highlighter-rouge">C(a, -)</code> (in this case <code class="language-plaintext highlighter-rouge">() -&gt; x</code>) to <code class="language-plaintext highlighter-rouge">F</code> (in this case <code class="language-plaintext highlighter-rouge">List x</code>) are one-to-one with the elements of <code class="language-plaintext highlighter-rouge">F a</code>. So the data type <code class="language-plaintext highlighter-rouge">D (() -&gt; x) -&gt; List x</code> is another representation of <code class="language-plaintext highlighter-rouge">List ()</code>.</p>

<p>It’s pretty easy to see why this is the case - a function of the form <code class="language-plaintext highlighter-rouge">f: () -&gt; x</code> is essentially a container for a single value of <code class="language-plaintext highlighter-rouge">x</code>. So the elements of <code class="language-plaintext highlighter-rouge">D</code> are all of the form:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d1 f = [f ()]
d2 f = [f (), f ()]
...
</code></pre></div></div>

<h1 id="section-16-yoneda-embedding">Section 16: Yoneda Embedding</h1>

<h5 id="p161-express-the-co-yoneda-embedding-in-haskell">p16.1 Express the co-Yoneda embedding in Haskell.</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">forward</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span>
<span class="n">forward</span> <span class="n">atob</span> <span class="o">=</span> <span class="nf">\</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">atob</span> <span class="o">.</span> <span class="n">f</span>

<span class="n">backward</span> <span class="o">::</span> <span class="p">((</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="n">backward</span> <span class="n">xToAToXToB</span> <span class="o">=</span> <span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">xToAToXToB</span> <span class="n">id</span><span class="p">)</span> <span class="n">a</span>
</code></pre></div></div>

<h5 id="p163-work-out-the-yoneda-embedding-for-a-monoid-what-functor-corresponds-to-the-monoids-single-object-what-natural-transformations-correspond-to-monoid-morphisms">p16.3 Work out the Yoneda embedding for a monoid. What functor corresponds to the monoid’s single object? What natural transformations correspond to monoid morphisms?</h5>
<p><em>Solution</em>
In the single-element category view of monoid, we have a single element and the morphisms follow the monoid association rules. We will call this category <code class="language-plaintext highlighter-rouge">M</code>.
The Yoneda embedding maps the single object <code class="language-plaintext highlighter-rouge">a</code> to the functor <code class="language-plaintext highlighter-rouge">M(a, -)</code>, which is the functor in <code class="language-plaintext highlighter-rouge">[M, Set]</code> that maps the single element <code class="language-plaintext highlighter-rouge">a</code> to the set <code class="language-plaintext highlighter-rouge">M(a,a)</code>.
The Yoneda embedding maps each morphism in <code class="language-plaintext highlighter-rouge">M</code> to the identity natural transformation that maps the functor <code class="language-plaintext highlighter-rouge">M(a, -)</code> to itself.</p>

<h5 id="p164-what-is-the-application-of-the-covariant-yoneda-embedding-to-preorders-question-suggested-by-gershom-bazerman">p16.4 What is the application of the covariant Yoneda embedding to preorders? (Question suggested by Gershom Bazerman.)</h5>
<p>In a preorder category <code class="language-plaintext highlighter-rouge">C</code>, if and only if a morphism  <code class="language-plaintext highlighter-rouge">f: b -&gt; a</code> exists, we have exactly one natural transformation between <code class="language-plaintext highlighter-rouge">C(a, -)</code> and <code class="language-plaintext highlighter-rouge">C(b, -)</code>. Since there are no functions that map non-empty sets into the empty set, we see that if <code class="language-plaintext highlighter-rouge">C(a, x)</code> is nonempty, then <code class="language-plaintext highlighter-rouge">C(b, x)</code> must be nonempty as well.</p>

<p>Therefore, we have the condition: <code class="language-plaintext highlighter-rouge">b &lt;= a</code>, if and only if for all <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">a &lt;= x</code> implies <code class="language-plaintext highlighter-rouge">b &lt;= x</code></p>

<h5 id="p165-yoneda-embedding-can-be-used-to-embed-an-arbitrary-functor-category-c-d-in-the-functor-category-c-d-set-figure-out-how-it-works-on-morphisms-which-in-this-case-are-natural-transformations">p16.5 Yoneda embedding can be used to embed an arbitrary functor category <code class="language-plaintext highlighter-rouge">[C, D]</code> in the functor category <code class="language-plaintext highlighter-rouge">[[C, D], Set]</code>. Figure out how it works on morphisms (which in this case are natural transformations).</h5>
<p><em>Solution</em>
For any natural transformation <code class="language-plaintext highlighter-rouge">NatAB</code> between the functors <code class="language-plaintext highlighter-rouge">Fb: C -&gt; D</code> and <code class="language-plaintext highlighter-rouge">Fa: C -&gt; D</code> such that <code class="language-plaintext highlighter-rouge">NatAB: Fb -&gt; Fa</code>, the Yoneda embedding maps it to the natural transformation:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NYoneda: [C, D](Fa, -) -&gt; [C, D](Fb, -)
</code></pre></div></div>
<p>Where</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[C, D](Fa, -): Fx -&gt; NatAX
NatAX: Fa -&gt; Fx
[C, D](Fb, -): Fx -&gt; NatBX
NatBX: Fb -&gt; Fx
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">NYoneda</code> operates on <code class="language-plaintext highlighter-rouge">[C, D](Fa, -)</code> by post-composing <code class="language-plaintext highlighter-rouge">NatAB</code> to the natural transformations in the output <code class="language-plaintext highlighter-rouge">NatAX</code>, which maps the output set to <code class="language-plaintext highlighter-rouge">NatBX</code>, which maps <code class="language-plaintext highlighter-rouge">([C, D](Fa, -): Fx -&gt; NatAX) -&gt; ([C, D](Fb, -): Fx -&gt; NatBX)</code></p>

<h1 id="section-17-its-all-about-morphisms">Section 17: It’s All About Morphisms</h1>

<h5 id="p171-consider-some-degenerate-cases-of-a-naturality-condition-and-draw-the-appropriate-diagrams-for-instance-what-happens-if-either-functor-f-or-g-map-both-objects-a-and-b-the-ends-of-f--a---b-to-the-same-object-eg-f-a--f-b-or-g-a--g-b-notice-that-you-get-a-cone-or-a-co-cone-this-way-then-consider-cases-where-either-f-a--g-a-or-f-b--g-b-finally-what-if-you-start-with-a-morphism-that-loops-on-itself--f--a---a">p17.1 Consider some degenerate cases of a naturality condition and draw the appropriate diagrams. For instance, what happens if either functor <code class="language-plaintext highlighter-rouge">F</code> or <code class="language-plaintext highlighter-rouge">G</code> map both objects <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> (the ends of <code class="language-plaintext highlighter-rouge">f :: a -&gt; b</code>) to the same object, e.g., <code class="language-plaintext highlighter-rouge">F a = F b</code> or <code class="language-plaintext highlighter-rouge">G a = G b</code>? (Notice that you get a cone or a co-cone this way.) Then consider cases where either<code class="language-plaintext highlighter-rouge"> F a = G a</code> or <code class="language-plaintext highlighter-rouge">F b = G b</code>. Finally, what if you start with a morphism that loops on itself — <code class="language-plaintext highlighter-rouge">f :: a -&gt; a</code>?</h5>
<p><em>Solution</em></p>

<p>For the following subproblems, let’s assume we have some function <code class="language-plaintext highlighter-rouge">f: a-&gt;b</code> and natural transformation <code class="language-plaintext highlighter-rouge">α</code> between functors <code class="language-plaintext highlighter-rouge">F</code> and <code class="language-plaintext highlighter-rouge">G</code>.</p>

<h6 id="p1711">p17.1.1</h6>
<p>Say <code class="language-plaintext highlighter-rouge">Fa = Fb</code>. Then <code class="language-plaintext highlighter-rouge">Ga = Gb</code> because:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(α . Ff) Fa =
    α . Fb =
    α . Fa =
    Ga

(Gf * α) Fa =
    Gf Ga =
    Gb
</code></pre></div></div>

<h6 id="p1712">p17.1.2</h6>
<p>Say <code class="language-plaintext highlighter-rouge">Ga = Gb</code>. Then <code class="language-plaintext highlighter-rouge">αB Fb = αA Fa</code>, but we can’t conclude that <code class="language-plaintext highlighter-rouge">Fb = Fa</code>, because it’s possible that <code class="language-plaintext highlighter-rouge">G</code> is the constant functor.</p>

<h6 id="p1713">p17.1.3</h6>

<p>Say <code class="language-plaintext highlighter-rouge">Fa = Ga</code>. Then <code class="language-plaintext highlighter-rouge">Gf: Fa -&gt; Gb</code> and since <code class="language-plaintext highlighter-rouge">αA Fa = Ga</code>, <code class="language-plaintext highlighter-rouge">αA</code> is the identity.</p>

<h6 id="p1714">p17.1.4</h6>
<p>Say <code class="language-plaintext highlighter-rouge">Fb = Gb</code>. Then <code class="language-plaintext highlighter-rouge">Ff: Fa -&gt; Gb</code> and since <code class="language-plaintext highlighter-rouge">αB Fb = Gb</code>, <code class="language-plaintext highlighter-rouge">αB</code> is the identity.</p>

<h6 id="p1715">p17.1.5</h6>
<p>Say <code class="language-plaintext highlighter-rouge">f: a -&gt; a</code>. Then <code class="language-plaintext highlighter-rouge">αA * Ff = Gf * αA</code>.</p>

<h1 id="section-18-adjunctions">Section 18: Adjunctions</h1>

<h5 id="p181-derive-the-naturality-square-for-ψ-the-transformation-between-the-two-contravariant-functors">p18.1 Derive the naturality square for <code class="language-plaintext highlighter-rouge">ψ</code>, the transformation between the two (contravariant) functors:</h5>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a -&gt; C(L a, b)
a -&gt; D(a, R b)
</code></pre></div></div>
<p><em>Solution</em>
Say we have</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f  :: a1 -&gt; a2
F f :: C(L a1, b) -&gt; C(L a2, b)
G f :: D(a1, R b) -&gt; D(a2, R b)
</code></pre></div></div>
<p>Where <code class="language-plaintext highlighter-rouge">L</code> and <code class="language-plaintext highlighter-rouge">R</code> are functors</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L :: D(a, R b) -&gt; C(L a, b)
R :: C(L a, b) -&gt; D(a, R b)
</code></pre></div></div>

<p>and define the natural transformation <code class="language-plaintext highlighter-rouge">ψ: G -&gt; F</code> such that</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ψg1 :: D(a1, R b) -&gt; C(L a1, b)
ψg2 :: D(a2, R b) -&gt; C(L a2, b)
</code></pre></div></div>

<p>Now consider the morphisms <code class="language-plaintext highlighter-rouge">g1: a1 -&gt; R</code> and <code class="language-plaintext highlighter-rouge">g2: a2 -&gt; R b</code>. We want to prove that <code class="language-plaintext highlighter-rouge">F f * ψg1 = ψg2 * G f</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ψg2 * G f G a1 = // definition of f
  ψg2 * G a2 = // definition of G
  ψg2 * D(a2, R b) = // definition of ψg2
  C(L a2, b) = // definition of G
  F a2 = // definition of F
  F f * F a1 = // definition of f
  F f * ψg1 G a1  // definition of ψg1
</code></pre></div></div>

<h5 id="p182-derive-the-counit-ε-starting-from-the-hom-sets-isomorphism-in-the-second-definition-of-the-adjunction">p18.2 Derive the counit <code class="language-plaintext highlighter-rouge">ε</code> starting from the hom-sets isomorphism in the second definition of the adjunction.</h5>
<p><em>Solution</em>
Assume that <code class="language-plaintext highlighter-rouge">C(L d, c) ≅ D(d, R c)</code> holds for any <code class="language-plaintext highlighter-rouge">c</code> in <code class="language-plaintext highlighter-rouge">C</code> and <code class="language-plaintext highlighter-rouge">d</code> in <code class="language-plaintext highlighter-rouge">D</code>. We want to prove that there exists some natural transformation <code class="language-plaintext highlighter-rouge">ε :: L . R -&gt; Ic</code>.</p>

<p>Say <code class="language-plaintext highlighter-rouge">d = R c</code>, then <code class="language-plaintext highlighter-rouge">C((L . R) c, c) ≅ D(R c, R c)</code>. Since <code class="language-plaintext highlighter-rouge">D(Rc, Rc)</code> contains at least the identity, our natural transformation from <code class="language-plaintext highlighter-rouge">D(R c, R c) -&gt; C((L . R) c, I c)</code> must map to a non-empty set. Therefore, we have some set of morphisms that map from <code class="language-plaintext highlighter-rouge">(L . R) c -&gt; I c</code> for any <code class="language-plaintext highlighter-rouge">c</code>. These morphisms form a natural transformation from <code class="language-plaintext highlighter-rouge">L * R -&gt; Ic</code>, which is <code class="language-plaintext highlighter-rouge">ε</code>.</p>

<h5 id="p183-complete-the-proof-of-equivalence-of-the-two-definitions-of-the-adjunction">p18.3 Complete the proof of equivalence of the two definitions of the adjunction.</h5>
<p><em>Solution</em>
In order to prove that the two definitions are equivalent, we need to prove the equivalence of the isomorphism <code class="language-plaintext highlighter-rouge">C(L d, c) ≅ D(d, R c)</code> and the existence of two natural transformations: the unit <code class="language-plaintext highlighter-rouge">η</code> and the counit <code class="language-plaintext highlighter-rouge">ε</code>.</p>

<p>In the text we proved that <code class="language-plaintext highlighter-rouge">C(L d, c) ≅ D(d, R c)</code> implies the existence of the <code class="language-plaintext highlighter-rouge">η</code> and that the existence of the <code class="language-plaintext highlighter-rouge">η</code> and <code class="language-plaintext highlighter-rouge">ε</code> implies the existence of a mapping from <code class="language-plaintext highlighter-rouge">C(L d, c)</code> to <code class="language-plaintext highlighter-rouge">D(d, R c)</code>. In <strong>p18.2</strong>, we proved that <code class="language-plaintext highlighter-rouge">C(L d, c) ≅ D(d, R c)</code> implies the existence of the <code class="language-plaintext highlighter-rouge">ε</code>. Therefore, we still need to prove that the existence of the <code class="language-plaintext highlighter-rouge">η</code> and <code class="language-plaintext highlighter-rouge">ε</code> implies the existence of <code class="language-plaintext highlighter-rouge">ψ :: D(d, R c) -&gt; C(L d, c)</code></p>

<p>For some morphism  <code class="language-plaintext highlighter-rouge">f :: d -&gt; R c</code>, we can apply <code class="language-plaintext highlighter-rouge">εc * L</code> to form the morphism:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>εc . L f =
    L d -&gt; εc L . R c =
    L d -&gt; c =
    ψf
</code></pre></div></div>

<h5 id="p1845-show-that-the-coproduct-can-be-defined-by-an-adjunction-start-with-the-definition-of-the-factorizer-for-a-coproduct-show-that-the-coproduct-is-the-left-adjoint-of-the-diagonal-functor">p18.4/5 Show that the coproduct can be defined by an adjunction. Start with the definition of the factorizer for a coproduct. Show that the coproduct is the left adjoint of the diagonal functor.</h5>
<p><em>Solution</em>
<em>(In this solution, we assume C is Set or Hask)</em>
We want to prove that <code class="language-plaintext highlighter-rouge">C(Either a b, c) ≅ (C × C)(&lt;a, b&gt;, Δ c)</code>. A homset in <code class="language-plaintext highlighter-rouge">CxC</code> is <code class="language-plaintext highlighter-rouge">(C×C)(&lt;a, b&gt;, Δ c)</code>, which consists of pairs of functions <code class="language-plaintext highlighter-rouge">a -&gt; c, b -&gt; c</code> and a homset in <code class="language-plaintext highlighter-rouge">C</code> is <code class="language-plaintext highlighter-rouge">C(Either a b, c)</code>, which consists of functions <code class="language-plaintext highlighter-rouge">(Either a b -&gt; c)</code></p>

<p>We can define a natural transformation between these two homsets with the <code class="language-plaintext highlighter-rouge">factorizer</code> and <code class="language-plaintext highlighter-rouge">inversefactorizer</code> functions.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>factorizer :: (C×C)(&lt;a, b&gt;, Δ c) -&gt; C(Either a b, c)
inversefactorizer :: C(Either a b, c) -&gt; (C×C)(&lt;a, b&gt;, Δ c)
</code></pre></div></div>

<p>We can write these in pseudo-haskell as</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>factorizer :: ((a -&gt; c), (b -&gt; c)) -&gt; (Either a b -&gt; c)
factorizer (i,j) (Left a) = i a
factorizer (i,j) (Right b) = j b

inversefactorizer :: (Either a b -&gt; c) -&gt; ((a -&gt; c), (b -&gt; c))
inversefactorizer m = (\a -&gt; m Left a), (\b -&gt; m Right b)
</code></pre></div></div>
<p>Now note that because these are both polymorphic in <code class="language-plaintext highlighter-rouge">a,b,c</code>, both <code class="language-plaintext highlighter-rouge">factorizer</code> and <code class="language-plaintext highlighter-rouge">inversefactorizer</code> are natural, so <code class="language-plaintext highlighter-rouge">C(Either a b, c) ≅ (C × C)(&lt;a, b&gt;, Δ c)</code>.</p>

<h5 id="p186-define-the-adjunction-between-a-product-and-a-function-object-in-haskell">p18.6 Define the adjunction between a product and a function object in Haskell.</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">producttofunction</span> <span class="o">::</span> <span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">z</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span>
<span class="n">producttofunction</span> <span class="n">f</span> <span class="o">=</span> <span class="nf">\</span><span class="n">z</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">a</span><span class="p">))</span>

<span class="n">functiontoproduct</span> <span class="o">::</span> <span class="p">(</span><span class="n">z</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="n">functiontoproduct</span> <span class="n">f</span> <span class="o">=</span> <span class="nf">\</span><span class="n">z_a</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="n">f</span> <span class="p">(</span><span class="n">fst</span> <span class="n">z_a</span><span class="p">))</span> <span class="p">(</span><span class="n">snd</span> <span class="n">z_a</span><span class="p">))</span>
</code></pre></div></div>

<h1 id="section-19-freeforgetful-adjunctions">Section 19: Free/Forgetful Adjunctions</h1>

<h5 id="p191-consider-a-free-monoid-built-from-a-singleton-set-as-its-generator-show-that-there-is-a-one-to-one-correspondence-between-morphisms-from-this-free-monoid-to-any-monoid-m-and-functions-from-the-singleton-set-to-the-underlying-set-of-m">p19.1 Consider a free monoid built from a singleton set as its generator. Show that there is a one-to-one correspondence between morphisms from this free monoid to any monoid <code class="language-plaintext highlighter-rouge">m</code>, and functions from the singleton set to the underlying set of m`.</h5>
<p><em>Solution</em></p>

<p><strong>Forward</strong>
Consider a morphism from the free monoid with the singleton set as its generator to <code class="language-plaintext highlighter-rouge">m</code>. This morphism maps the generator element <code class="language-plaintext highlighter-rouge">e</code> to some <code class="language-plaintext highlighter-rouge">m1</code> in <code class="language-plaintext highlighter-rouge">m</code>. There exists exactly one function in the homset between the singleton set and the underlying set of <code class="language-plaintext highlighter-rouge">m</code> that maps <code class="language-plaintext highlighter-rouge">()</code> to <code class="language-plaintext highlighter-rouge">m1</code>, so we can define a forward mapping.</p>

<p><strong>Backward</strong>
Consider a function from the singleton set to the underlying set of <code class="language-plaintext highlighter-rouge">m</code>. This function “chooses” a single element <code class="language-plaintext highlighter-rouge">m1</code> from the underlying set of <code class="language-plaintext highlighter-rouge">m</code>. We can define exactly one homomorphism between the singleton free monoid and <code class="language-plaintext highlighter-rouge">m</code> that maps the generator element <code class="language-plaintext highlighter-rouge">e</code> to <code class="language-plaintext highlighter-rouge">m1</code>, since any such homomorphism must satisfy the following:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 -&gt; unit
e -&gt; m1
ee -&gt; m1m1
eee -&gt; m1m1m1
</code></pre></div></div>
<p>so there is exactly one such homomorphism and we can define a backward mapping.</p>
<h1 id="section-20-monads-programmers-definition-no-challenges">Section 20: Monads: Programmer’s Definition (No Challenges)</h1>

<h1 id="section-21-monads-and-effects-no-challenges">Section 21: Monads and Effects (No Challenges)</h1>
<h1 id="section-22-monads-categorically-no-challenges">Section 22: Monads Categorically (No Challenges)</h1>
<h1 id="section-24-f-algebras">Section 24: F-Algebras</h1>
<h5 id="p241-implement-the-evaluation-function-for-a-ring-of-polynomials-of-one-variable-you-can-represent-a-polynomial-as-a-list-of-coefficients-in-front-of-powers-of-x-for-instance-4x2-1-would-be-represented-as-starting-with-the-zeroth-power--1-0-4">p24.1 Implement the evaluation function for a ring of polynomials of one variable. You can represent a polynomial as a list of coefficients in front of powers of x. For instance, <code class="language-plaintext highlighter-rouge">4x^2-1</code> would be represented as (starting with the zero’th power) <code class="language-plaintext highlighter-rouge">[-1, 0, 4]</code>.</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">polyEval</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Double</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
<span class="n">polyEval</span> <span class="n">coefficients</span> <span class="n">value</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="n">sumSoFar</span> <span class="o">-&gt;</span> <span class="n">sumSoFar</span> <span class="o">+</span> <span class="n">coeff</span> <span class="o">*</span> <span class="p">(</span><span class="n">value</span> <span class="o">**</span> <span class="n">power</span><span class="p">))</span> <span class="mf">0.0</span> <span class="p">(</span><span class="n">zip</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="n">coefficients</span><span class="p">)</span>
<span class="n">isTrue</span> <span class="o">=</span> <span class="mf">99.0</span> <span class="o">==</span>  <span class="p">(</span><span class="n">polyEval</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>
<h5 id="p242-generalize-the-previous-construction-to-polynomials-of-many-independent-variables-like-x2y-3y3z">p24.2 Generalize the previous construction to polynomials of many independent variables, like <code class="language-plaintext highlighter-rouge">x^2y-3y^3z</code>.</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">raiseAndProd</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
<span class="n">raiseAndProd</span> <span class="n">values</span> <span class="n">powers</span>  <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span> <span class="n">prodSoFar</span> <span class="o">-&gt;</span> <span class="n">prodSoFar</span> <span class="o">*</span> <span class="p">(</span><span class="n">value</span> <span class="o">**</span> <span class="n">power</span><span class="p">))</span> <span class="mf">1.0</span> <span class="p">(</span><span class="n">zip</span> <span class="n">values</span> <span class="n">powers</span><span class="p">)</span>

<span class="n">polyMultiEval</span> <span class="o">::</span> <span class="p">[(</span><span class="kt">Double</span><span class="p">,</span> <span class="p">[</span><span class="kt">Double</span><span class="p">])]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Double</span>
<span class="n">polyMultiEval</span> <span class="n">coeffsExps</span> <span class="n">values</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">powers</span><span class="p">)</span> <span class="n">sumSoFar</span> <span class="o">-&gt;</span> <span class="n">sumSoFar</span> <span class="o">+</span> <span class="n">coeff</span> <span class="o">*</span> <span class="p">(</span><span class="n">raiseAndProd</span> <span class="n">values</span> <span class="n">powers</span><span class="p">))</span> <span class="mf">0.0</span> <span class="n">coeffsExps</span>

<span class="n">isTrue1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2580.0</span> <span class="o">==</span> <span class="p">(</span><span class="n">polyMultiEval</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="n">isTrue2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">==</span> <span class="p">(</span><span class="n">polyMultiEval</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<h5 id="p243-implement-the-algebra-for-the-ring-of-22-matrices">p24.3 Implement the algebra for the ring of <code class="language-plaintext highlighter-rouge">2×2</code> matrices.</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">MatExpr</span> <span class="o">=</span> <span class="kt">RZero</span>
  <span class="o">|</span> <span class="kt">ROne</span>
  <span class="o">|</span> <span class="kt">RCompA</span>
  <span class="o">|</span> <span class="kt">RCompB</span>
  <span class="o">|</span> <span class="kt">RCompC</span>
  <span class="o">|</span> <span class="kt">RCompD</span>
  <span class="o">|</span> <span class="kt">RAdd</span> <span class="kt">MatExpr</span> <span class="kt">MatExpr</span>
  <span class="o">|</span> <span class="kt">RMul</span> <span class="kt">MatExpr</span> <span class="kt">MatExpr</span>
  <span class="o">|</span> <span class="kt">RNeg</span> <span class="kt">MatExpr</span>


<span class="kr">type</span> <span class="kt">MatrixTwoTwo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>

<span class="n">mCompA</span> <span class="o">::</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">mCompA</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">mCompB</span> <span class="o">::</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">mCompB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">mCompC</span> <span class="o">::</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">mCompC</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">mCompD</span> <span class="o">::</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">mCompD</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">mZero</span> <span class="o">::</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">mZero</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">mEye</span> <span class="o">::</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">mEye</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">mAdd</span> <span class="o">::</span> <span class="kt">MatrixTwoTwo</span> <span class="o">-&gt;</span> <span class="kt">MatrixTwoTwo</span> <span class="o">-&gt;</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">mAdd</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">,</span><span class="n">c1</span><span class="p">,</span><span class="n">d1</span><span class="p">)</span> <span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">d2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b1</span> <span class="o">+</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span><span class="p">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span><span class="p">)</span>

<span class="n">mMult</span> <span class="o">::</span> <span class="kt">MatrixTwoTwo</span> <span class="o">-&gt;</span> <span class="kt">MatrixTwoTwo</span> <span class="o">-&gt;</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">mMult</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">,</span><span class="n">c1</span><span class="p">,</span><span class="n">d1</span><span class="p">)</span> <span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">d2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">c2</span><span class="p">,</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">b2</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">d2</span><span class="p">,</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">+</span> <span class="n">d1</span> <span class="o">*</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">b2</span> <span class="o">+</span> <span class="n">d1</span> <span class="o">*</span> <span class="n">d2</span><span class="p">)</span>

<span class="n">mNeg</span> <span class="o">::</span> <span class="kt">MatrixTwoTwo</span> <span class="o">-&gt;</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">mNeg</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">b1</span><span class="p">,</span><span class="n">c1</span><span class="p">,</span><span class="n">d1</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">a1</span><span class="p">,</span><span class="o">-</span><span class="n">b1</span><span class="p">,</span><span class="o">-</span><span class="n">c1</span><span class="p">,</span><span class="o">-</span><span class="n">d1</span><span class="p">)</span>

<span class="n">evalZ</span> <span class="o">::</span> <span class="kt">MatExpr</span> <span class="o">-&gt;</span> <span class="kt">MatrixTwoTwo</span>
<span class="n">evalZ</span> <span class="kt">RZero</span> <span class="o">=</span> <span class="n">mZero</span>
<span class="n">evalZ</span> <span class="kt">ROne</span> <span class="o">=</span> <span class="n">mEye</span>
<span class="n">evalZ</span> <span class="kt">RCompA</span> <span class="o">=</span> <span class="n">mCompA</span>
<span class="n">evalZ</span> <span class="kt">RCompB</span> <span class="o">=</span> <span class="n">mCompB</span>
<span class="n">evalZ</span> <span class="kt">RCompC</span> <span class="o">=</span> <span class="n">mCompC</span>
<span class="n">evalZ</span> <span class="kt">RCompD</span> <span class="o">=</span> <span class="n">mCompD</span>
<span class="n">evalZ</span> <span class="p">(</span><span class="kt">RAdd</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">mAdd</span> <span class="p">(</span><span class="n">evalZ</span> <span class="n">e1</span><span class="p">)</span> <span class="p">(</span><span class="n">evalZ</span> <span class="n">e2</span><span class="p">)</span>
<span class="n">evalZ</span> <span class="p">(</span><span class="kt">RMul</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">mMult</span> <span class="p">(</span><span class="n">evalZ</span> <span class="n">e1</span><span class="p">)</span> <span class="p">(</span><span class="n">evalZ</span> <span class="n">e2</span><span class="p">)</span>
<span class="n">evalZ</span> <span class="p">(</span><span class="kt">RNeg</span> <span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">mNeg</span> <span class="p">(</span><span class="n">evalZ</span> <span class="n">e</span><span class="p">)</span>


<span class="n">matrixExpression</span> <span class="o">::</span> <span class="kt">MatExpr</span>
<span class="n">matrixExpression</span> <span class="o">=</span> <span class="kt">RMul</span> <span class="p">(</span><span class="kt">RAdd</span> <span class="kt">RCompA</span> <span class="kt">RCompB</span><span class="p">)</span> <span class="p">(</span><span class="kt">RAdd</span> <span class="kt">RCompC</span> <span class="kt">RCompD</span><span class="p">)</span>
<span class="n">isTrue</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">evalZ</span> <span class="n">matrixExpression</span><span class="p">))</span>
</code></pre></div></div>
<h5 id="p244-define-a-coalgebra-whose-anamorphism-produces-a-list-of-squares-of-natural-numbers">p24.4 Define a coalgebra whose anamorphism produces a list of squares of natural numbers.</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">newtype</span> <span class="kt">Fix</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Fix</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="kt">Fix</span> <span class="n">f</span><span class="p">))</span>
<span class="n">unFix</span> <span class="o">::</span> <span class="kt">Fix</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Fix</span> <span class="n">f</span><span class="p">)</span>
<span class="n">unFix</span> <span class="p">(</span><span class="kt">Fix</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">cata</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Fix</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">cata</span> <span class="n">alg</span> <span class="o">=</span> <span class="n">alg</span> <span class="o">.</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">cata</span> <span class="n">alg</span><span class="p">)</span> <span class="o">.</span> <span class="n">unFix</span>

<span class="n">ana</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Fix</span> <span class="n">f</span>
<span class="n">ana</span> <span class="n">coalg</span> <span class="o">=</span> <span class="kt">Fix</span> <span class="o">.</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">ana</span> <span class="n">coalg</span><span class="p">)</span> <span class="o">.</span> <span class="n">coalg</span>

<span class="kr">data</span> <span class="kt">StreamF</span> <span class="n">e</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">StreamF</span> <span class="n">e</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="kt">Functor</span>

<span class="n">toListC</span> <span class="o">::</span> <span class="kt">Fix</span> <span class="p">(</span><span class="kt">StreamF</span> <span class="n">e</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
<span class="n">toListC</span> <span class="o">=</span> <span class="n">cata</span> <span class="n">al</span>
  <span class="kr">where</span> <span class="n">al</span> <span class="o">::</span> <span class="kt">StreamF</span> <span class="n">e</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="n">al</span> <span class="p">(</span><span class="kt">StreamF</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span> <span class="o">:</span> <span class="n">a</span>

<span class="n">nat</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">StreamF</span> <span class="kt">Int</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="n">nat</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ns</span><span class="p">)</span> <span class="o">=</span> <span class="kt">StreamF</span> <span class="p">(</span><span class="n">p</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="n">ns</span>

<span class="n">squaresStream</span> <span class="o">::</span> <span class="kt">Fix</span> <span class="p">(</span><span class="kt">StreamF</span> <span class="kt">Int</span><span class="p">)</span>
<span class="n">squaresStream</span> <span class="o">=</span> <span class="n">ana</span> <span class="n">nat</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span>

<span class="n">squaresList</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="n">squaresList</span> <span class="o">=</span> <span class="n">toListC</span> <span class="n">squaresStream</span>
</code></pre></div></div>
<h5 id="p245-use-unfoldr-to-generate-a-list-of-the-first-n-primes">p24.5 Use <code class="language-plaintext highlighter-rouge">unfoldr</code> to generate a list of the first n primes.</h5>
<p><em>Solution</em></p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">listSieve</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span>
<span class="n">listSieve</span> <span class="p">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ns</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="n">notdiv</span> <span class="n">p</span><span class="p">)</span> <span class="n">ns</span><span class="p">))</span>
  <span class="kr">where</span> <span class="n">notdiv</span> <span class="n">p</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">p</span> <span class="o">/=</span> <span class="mi">0</span>

<span class="n">primeFilteredList</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="n">primeFilteredList</span> <span class="o">=</span> <span class="n">unfoldr</span> <span class="n">listSieve</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span>

<span class="n">isTrue1</span> <span class="o">=</span> <span class="n">primeFilteredList</span><span class="o">!!</span><span class="mi">0</span> <span class="o">==</span> <span class="mi">2</span>
<span class="n">isTrue2</span> <span class="o">=</span> <span class="n">primeFilteredList</span><span class="o">!!</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">7</span>
</code></pre></div></div>

<h1 id="section-25-algebras-for-monads">Section 25: Algebras for Monads</h1>

<h5 id="p251-what-is-the-action-of-the-free-functor-f--c---ct-on-morphisms-hint-use-the-naturality-condition-for-monadic-μ">p25.1 What is the action of the free functor <code class="language-plaintext highlighter-rouge">F :: C -&gt; C^T</code> on morphisms. Hint: use the naturality condition for monadic <code class="language-plaintext highlighter-rouge">μ</code>.</h5>
<p><em>Solution</em>
First, note that <code class="language-plaintext highlighter-rouge">F a = (T a, μa)</code>. Since <code class="language-plaintext highlighter-rouge">μ</code> is natural, we see that <code class="language-plaintext highlighter-rouge">T f . μa = μb . (T . T) f</code>.  Therefore, for some <code class="language-plaintext highlighter-rouge">f :: a -&gt; b</code>, the action of <code class="language-plaintext highlighter-rouge">F</code> on <code class="language-plaintext highlighter-rouge">f</code> is:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmap f (T a, μa) = (fmap f T a, T f . μa)
</code></pre></div></div>

<h5 id="p252-define-the-adjunction-uw--fw">p25.2 Define the adjunction: <code class="language-plaintext highlighter-rouge">U^W ⊣ F^W</code></h5>
<p><em>Solution</em>
First, we define the unit <code class="language-plaintext highlighter-rouge">η :: I -&gt; F^W . U^W</code>. Since it’s the case that</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F^W . U^W (W a, f) =
    F^W (W a) =
    (W W a, δWa)
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">η</code> needs to map <code class="language-plaintext highlighter-rouge">(W a, f) -&gt; (W W a, δWa)</code>. We can accomplish this by using <code class="language-plaintext highlighter-rouge">f</code>, the co-evaluator of the co-algebra, to define the component of <code class="language-plaintext highlighter-rouge">η</code> at <code class="language-plaintext highlighter-rouge">(W a, f)</code></p>

<p>Next, we define the co-unit <code class="language-plaintext highlighter-rouge">ε :: U^W . F^W -&gt; I</code>. Since it’s the case that:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>U^W . F^W a =
    U^W . (W a, δa) =
    W a
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">ε</code> needs to map <code class="language-plaintext highlighter-rouge">W a -&gt; a</code> so we can use the <code class="language-plaintext highlighter-rouge">extract</code> method of the co-monad to define the component of <code class="language-plaintext highlighter-rouge">ε</code> at <code class="language-plaintext highlighter-rouge">Wa</code>.</p>

<h5 id="p253-prove-that-the-above-adjunction-reproduces-the-original-comonad">p25.3 Prove that the above adjunction reproduces the original comonad.</h5>
<p><em>Solution</em>
First, we can use the co-unit of the adjunction <code class="language-plaintext highlighter-rouge">ε</code> as the co-monadic extract, since <code class="language-plaintext highlighter-rouge">εWa W a = a</code></p>

<p>Next, we can use the unit of the adjunction to define the co-monadic <code class="language-plaintext highlighter-rouge">duplicate</code> as the horizontal composition of three natural transformations <code class="language-plaintext highlighter-rouge">U^W ◦ η ◦ F^W</code> where <code class="language-plaintext highlighter-rouge">U^W: U^W -&gt; U^W</code> and <code class="language-plaintext highlighter-rouge">F^W: F^W -&gt; F^W</code>. Since <code class="language-plaintext highlighter-rouge">F^W</code> lifts <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">(W a, δa)</code>, <code class="language-plaintext highlighter-rouge">η</code> picks the co-evaluator <code class="language-plaintext highlighter-rouge">δa</code> which maps <code class="language-plaintext highlighter-rouge">W a -&gt; W W a</code> and <code class="language-plaintext highlighter-rouge">U^W</code> has no action on morphisms, we see that <code class="language-plaintext highlighter-rouge">duplicate = U^W ◦ η ◦ F^W</code>.</p>

<h1 id="section-26-ends-and-coends-no-challenges">Section 26: Ends and Coends (No Challenges)</h1>

<h1 id="section-27-kan-extensions-no-challenges">Section 27: Kan Extensions (No Challenges)</h1>

<h1 id="section-28-enriched-categories-no-challenges">Section 28: Enriched Categories (No Challenges)</h1>

<h1 id="section-29-topoi">Section 29: Topoi</h1>

<h5 id="p291-show-that-the-function-f-that-is-the-pullback-of-true-along-the-characteristic-function-must-be-injective">p29.1 Show that the function <code class="language-plaintext highlighter-rouge">f</code> that is the pullback of <code class="language-plaintext highlighter-rouge">true</code> along the characteristic function must be injective.</h5>
<p><em>Solution</em>
If <code class="language-plaintext highlighter-rouge">f: a -&gt; b</code> is the pullback of <code class="language-plaintext highlighter-rouge">true</code> along the characteristic function, then for any <code class="language-plaintext highlighter-rouge">a*</code>, <code class="language-plaintext highlighter-rouge">f*: a* -&gt; b</code>, there exists some unique <code class="language-plaintext highlighter-rouge">h: a* -&gt; a</code> such that <code class="language-plaintext highlighter-rouge">f* = f . h</code></p>

<p>Consider the case where <code class="language-plaintext highlighter-rouge">a*</code> is the image of <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">f*</code> is the identity. If <code class="language-plaintext highlighter-rouge">f</code> is not injective, then for the <code class="language-plaintext highlighter-rouge">e1, e2, e1 != e2</code> in <code class="language-plaintext highlighter-rouge">a</code> such that <code class="language-plaintext highlighter-rouge">f(e1) = f(e2)</code>, <code class="language-plaintext highlighter-rouge">h</code> can map <code class="language-plaintext highlighter-rouge">f(e1) = f(e2)</code> to either <code class="language-plaintext highlighter-rouge">e1</code> or <code class="language-plaintext highlighter-rouge">e2</code>. Therefore <code class="language-plaintext highlighter-rouge">h</code> would not be unique, which implies that <code class="language-plaintext highlighter-rouge">f</code> must be injective.</p>

<h1 id="section-30-lawvere-theories">Section 30: Lawvere Theories</h1>

<h5 id="p301-enumarate-all-morphisms-between-2-and-3-in-f-the-skeleton-of-finset">p30.1 Enumarate all morphisms between <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> in <code class="language-plaintext highlighter-rouge">F</code> (the skeleton of <code class="language-plaintext highlighter-rouge">FinSet</code>).</h5>
<p><em>Solution</em>
<code class="language-plaintext highlighter-rouge">(0-&gt;0, 1-&gt;0), (0-&gt;0, 1-&gt;1), (0-&gt;0, 1-&gt;2), (0-&gt;1, 1-&gt;0), (0-&gt;1, 1-&gt;1), (0-&gt;1, 1-&gt;2)</code></p>

<h5 id="p302-show-that-the-category-of-models-for-the-lawvere-theory-of-monoids-is-equivalent-to-the-category-of-monad-algebras-for-the-list-monad">p30.2 Show that the category of models for the Lawvere theory of monoids is equivalent to the category of monad algebras for the list monad.</h5>
<p><em>Solution</em>
First, let’s note that the category of models of the Lawvere theory for monoids is equivalent to the category of all monoids, <code class="language-plaintext highlighter-rouge">Mon</code>. Now we will prove that <code class="language-plaintext highlighter-rouge">Mon</code> is equivalent to the category of monad algebras for the list monad.</p>

<p>First, given a monoid over the set <code class="language-plaintext highlighter-rouge">a</code>, we can produce an algebra <code class="language-plaintext highlighter-rouge">(a, f)</code> where <code class="language-plaintext highlighter-rouge">f</code> maps the list <code class="language-plaintext highlighter-rouge">L</code> to the monoidal product of the elements in <code class="language-plaintext highlighter-rouge">L</code>. Next, given an algebra <code class="language-plaintext highlighter-rouge">(a, f)</code>, we can produce a monoid over <code class="language-plaintext highlighter-rouge">a</code> by defining the monoidal product of <code class="language-plaintext highlighter-rouge">a1, a2</code> to be <code class="language-plaintext highlighter-rouge">f ([a1] cat [a2])</code>. The unit of this monoid is <code class="language-plaintext highlighter-rouge">[]</code>, and because of the monad condition <code class="language-plaintext highlighter-rouge">f . μa = f . T f</code> we see that:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f [a1, f [a2, a3]] =
  f [a1, a2, a3] =
  f [f [a1, a2], a3]
</code></pre></div></div>
<p>So the monoid associativity law is automatically satisfied.</p>

<h5 id="p303-the-lawvere-theory-of-monoids-generates-the-list-monad-show-that-its-binary-operations-can-be-generated-using-the-corresponding-kleisli-arrows">p30.3 The Lawvere theory of monoids generates the list monad. Show that its binary operations can be generated using the corresponding Kleisli arrows.</h5>
<p><em>Solution</em>
The binary operations in the Lawvere theory of monoids are elements of the homset <code class="language-plaintext highlighter-rouge">LMon(2, 1)</code>, which are functions of two arguments that we can implement with only the monoidal operator. Each of these functions can be defined by a list composed of only those 2 unique elements. Since each Kleisli arrow in the hom-set <code class="language-plaintext highlighter-rouge">KlT (1, 2)</code> corresponds to a list composed of elements from the 2 element set, we can represent each binary operation in the Lawvere theory of monoids with a Kleisli arrow in <code class="language-plaintext highlighter-rouge">KlT (1, 2)</code>.</p>

<h5 id="p304-finset-is-a-subcategory-of-set-and-there-is-a-functor-that-embeds-it-in-set-any-functor-on-set-can-be-restricted-to-finset-show-that-a-finitary-functor-is-the-left-kan-extension-of-its-own-restriction">p30.4 <code class="language-plaintext highlighter-rouge">FinSet</code> is a subcategory of <code class="language-plaintext highlighter-rouge">Set</code> and there is a functor that embeds it in <code class="language-plaintext highlighter-rouge">Set</code>. Any functor on <code class="language-plaintext highlighter-rouge">Set</code> can be restricted to <code class="language-plaintext highlighter-rouge">FinSet</code>. Show that a finitary functor is the left Kan extension of its own restriction</h5>
<p><em>Solution</em>
Say <code class="language-plaintext highlighter-rouge">K: Set -&gt; FinSet</code> is a functor that embeds a set into <code class="language-plaintext highlighter-rouge">FinSet</code>, such that for any finite set <code class="language-plaintext highlighter-rouge">n</code> in <code class="language-plaintext highlighter-rouge">Set</code>, <code class="language-plaintext highlighter-rouge">K n = n</code>. Then <code class="language-plaintext highlighter-rouge">FinSet(K n, a)</code> is a hom-set between elements in <code class="language-plaintext highlighter-rouge">FinSet</code>, and so <code class="language-plaintext highlighter-rouge">FinSet(K n, a) = a^(K n) = a^n</code>.</p>

<p>Now consider some finitary functor <code class="language-plaintext highlighter-rouge">F</code>. The left Kan extension of <code class="language-plaintext highlighter-rouge">F</code>’s restriction to <code class="language-plaintext highlighter-rouge">FinSet</code> along <code class="language-plaintext highlighter-rouge">K</code> is</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LanK F a =
  ∫^n FinSet(K n, a) × F n =
  ∫^n a^n × F n = \\ definition of finitary functor
  F
</code></pre></div></div>
<p>So a finitary functor is the left Kan extension of its own restriction.</p>

<h1 id="section-31-monads-monoids-and-categories">Section 31: Monads, Monoids, and Categories</h1>

<h5 id="p311-derive-unit-and-associativity-laws-for-the-tensor-product-defined-as-composition-of-endo-1-cells-in-a-bicategory">p31.1 Derive unit and associativity laws for the tensor product defined as composition of endo-1-cells in a bicategory.</h5>
<p><em>Solution</em></p>

<p><strong>Unit Law</strong>
The left and right compositions of any endo-1-cell <code class="language-plaintext highlighter-rouge">T</code> and the identity 1-cell <code class="language-plaintext highlighter-rouge">id</code> are <code class="language-plaintext highlighter-rouge">T . id</code> and <code class="language-plaintext highlighter-rouge">id . T</code>. By the definition of a bicategory there exist invertible 2-cells mapping each of these endo-1-cells to <code class="language-plaintext highlighter-rouge">T</code>.</p>

<p><strong>Associativity Law</strong>
Given three endo-1-cells <code class="language-plaintext highlighter-rouge">T1, T2, T3</code>, by the definition of a bicategory there exists an invertible 2-cell that maps between <code class="language-plaintext highlighter-rouge">((T1 . T2) . T3</code> and <code class="language-plaintext highlighter-rouge">T1 . (T2 . T3)</code>.</p>

<h5 id="p312-check-that-monad-laws-for-a-monad-in-span-correspond-to-identity-and-associativity-laws-in-the-resulting-category">p31.2 Check that monad laws for a monad in <code class="language-plaintext highlighter-rouge">Span</code> correspond to identity and associativity laws in the resulting category.</h5>
<p><em>Solution</em>
A monad in Span consists of an endo-1-cell that has the sets <code class="language-plaintext highlighter-rouge">Ar, Ob</code> with the functions</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dom :: Ar -&gt; Ob
cod :: Ar -&gt; Ob
</code></pre></div></div>
<p>and the associated 2-cells:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>μ: Ar x Ar -&gt; Ar
η: Ob -&gt; Ar
</code></pre></div></div>
<p>This monad defines a category consisting of the objects in <code class="language-plaintext highlighter-rouge">Ob</code> and the arrows in <code class="language-plaintext highlighter-rouge">Ar</code>, where each arrow in <code class="language-plaintext highlighter-rouge">Ar</code> connects <code class="language-plaintext highlighter-rouge">dom Ar</code> to <code class="language-plaintext highlighter-rouge">cod Ar</code>.</p>

<p><strong>Identity</strong>
<code class="language-plaintext highlighter-rouge">η</code> assigns an identity arrow to each object such that</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dom . η = id
cod . η = id
</code></pre></div></div>
<p>Therefore for any object <code class="language-plaintext highlighter-rouge">o1</code> in <code class="language-plaintext highlighter-rouge">Ob</code> and arrow <code class="language-plaintext highlighter-rouge">a1</code> in <code class="language-plaintext highlighter-rouge">Ar</code> where <code class="language-plaintext highlighter-rouge">cod a1 = o1</code>, we see that:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dom (μ (a1, η o1)) = dom a1
cod (μ (a1, η o1)) = cod (η o1) = o1 = cod a1
</code></pre></div></div>
<p>So the composition of an arrow with the identity arrow does not change that arrow’s domain or codomain.</p>

<p><strong>Associativity</strong>
By the monoid law for <code class="language-plaintext highlighter-rouge">μ</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>μ (Ar x μ (Ar x Ar)) = μ (μ (Ar x Ar) x Ar)
</code></pre></div></div>
<p>Therefore, for any arrows <code class="language-plaintext highlighter-rouge">a1, a2, a3</code>, we see that</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a1 . (a2 . a3) = (a1 . a2) . a3
</code></pre></div></div>

<h5 id="p313-show-that-a-monad-in-prof-is-an-identity-on-objects-functor">p31.3 Show that a monad in <code class="language-plaintext highlighter-rouge">Prof</code> is an identity-on-objects functor.</h5>
<p><em>Solution</em>
In <code class="language-plaintext highlighter-rouge">Prof</code>, we define a monad with an endo-profunctor <code class="language-plaintext highlighter-rouge">T</code> such that <code class="language-plaintext highlighter-rouge">T: Cop x C -&gt; Set</code>. The composition of profunctors is</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(q . p) a b = ∫^c p c a × q b c
</code></pre></div></div>
<p>So the composition of <code class="language-plaintext highlighter-rouge">T</code> with itself is:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(T . T) C C =
    ∫^c T c C × T C c = // existential quantifier
    T C C
</code></pre></div></div>
<p>Which implies that <code class="language-plaintext highlighter-rouge">T</code> must map each object in <code class="language-plaintext highlighter-rouge">C</code> to itself.</p>

<h5 id="p314-whats-a-monad-algebra-for-a-monad-in-span">p31.4 What’s a monad algebra for a monad in <code class="language-plaintext highlighter-rouge">Span</code>?</h5>
<p><em>Solution</em>
Given a monad <code class="language-plaintext highlighter-rouge">m</code> over some object <code class="language-plaintext highlighter-rouge">a</code>, we form an algebra over this monad with a map <code class="language-plaintext highlighter-rouge">alg :: m a -&gt; a</code> that satisfies commutativity conditions. For a monad in <code class="language-plaintext highlighter-rouge">Span</code>, we can use <code class="language-plaintext highlighter-rouge">dom</code> or <code class="language-plaintext highlighter-rouge">cod</code> for <code class="language-plaintext highlighter-rouge">alg</code>.</p>

<p><strong>Identity</strong> <code class="language-plaintext highlighter-rouge">alg . ηa = ida</code>
This holds by the definition of <code class="language-plaintext highlighter-rouge">η</code> for <code class="language-plaintext highlighter-rouge">Span</code></p>

<p><strong>Associativity</strong> <code class="language-plaintext highlighter-rouge">alg . μa = alg . m alg</code>
Without loss of generality, we can see the following:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dom . μa (a1, a2) =
    dom a1 =
    dom . m dom (a1, a2)
</code></pre></div></div>
:ET